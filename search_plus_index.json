{"./":{"url":"./","title":"zengmenglu","keywords":"","body":"Welcome To Zeng Menglu Zone! Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 00:01:59 "},"ComputerNetworks/computerNetworks.html":{"url":"ComputerNetworks/computerNetworks.html","title":"计算机网络","keywords":"","body":"计算机网络 应用层 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-04 23:57:14 "},"ComputerNetworks/applicationLayer.html":{"url":"ComputerNetworks/applicationLayer.html","title":"应用层","keywords":"","body":"http http请求 cookie与session 请求方法与幂等性 cookie v.s. session cookie存储在浏览器上，最大存储量为4KB。session存储在服务器端，大小无限制。 cookie可以轻松访问，但是session不能，因此session更安全。 设置cookie时间可使cookie过期，而删除回话需要执行session destroy操作。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 00:06:27 "},"OperatingSystem/operatingSystem.html":{"url":"OperatingSystem/operatingSystem.html","title":"操作系统","keywords":"","body":"操作系统 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 11:00:37 "},"OperatingSystem/processAndThread.html":{"url":"OperatingSystem/processAndThread.html","title":"进程与线程","keywords":"","body":"进程 进程间通信 1）消息队列（Message） 消息队列是消息的链接表。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 2）共享内存 使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 3）管道（Pipe）及有名管道（named pipe） 管道可用于具有亲缘关系进程间的通信（父子进程），有名管道克服了管道没有名字的限制，它还允许无亲缘关系进程间的通信； 4）信号（Signal） 信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身； 5）信号量（semaphore） 资源计数器。主要作为进程间以及同一进程不同线程之间的同步手段。 6）套接口（Socket） 更为一般的进程间通信机制，可用于不同机器之间的进程间通信。 线程 线程安全 LINK Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-10 21:55:39 "},"Golang/Golang.html":{"url":"Golang/Golang.html","title":"Golang","keywords":"","body":"Golang slice 携程 channel 底层实现 pprof go marshal 代码依赖 vendor gradlew Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-11 23:13:52 "},"DataStructAndAlgorithm/dataStructAndAlgorithm.html":{"url":"DataStructAndAlgorithm/dataStructAndAlgorithm.html","title":"数据结构与算法","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 10:55:51 "},"DataStructAndAlgorithm/leetcode.html":{"url":"DataStructAndAlgorithm/leetcode.html","title":"Leetcode","keywords":"","body":"目录 42. 缺失的第一个正数 46. 全排列 96. 不同的二叉搜索树 153. 寻找旋转排序数组中的最小值 200. 岛屿数量 403. 青蛙过河 698. 划分为k个相等的子集 779. 第K个语法符号 794. 有效的井字游戏 894. 所有可能的满二叉树 912. 排序数组 923. 三数之和的多种可能 993. 二叉树的堂兄弟节点 1277. 统计全为 1 的正方形子矩阵 1278. 分割回文串 III 42. 缺失的第一个正数 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 与剑指 offer第三题类似，不同之处在于可能出现负数或大于数组长度n的数。对于这样的数跳过即可，对其他1～n的数换到下标0～n-1的位置。如果数组内数据为[1,2,...,n], 那么第一个未出现的正数是n+1，所以第一个未出现的正数范围是1～n+1。 nums[i] == i+1 符合置换条件，不需要交换。 nums[i] == nums[nums[i]-1] 两个交换值相等的情况下，会产生死循环，所以也无需交换，继续下一个。 func firstMissingPositive(nums []int) int { n := len(nums) for i := 0; i n || nums[i] == i+1 || nums[i] == nums[nums[i]-1]){ i++ } if i46. 全排列 给定一个没有重复数字的序列，返回其所有可能的全排列。 TAG：【递归】【回溯】 假设数字序列为[0...n-1],首先是确定第一个数，将序号为0～n-1的数分别与第一个数交换位置。交换完了之后要恢复数组原貌，再确定第二个数，将第二个数后面所有数字和第二个数交换。如此，直到确定了所有数之后就得到了一个结果。 注意这里储存结果的二维数组必须得使用指针，否则结果传不出来。 如果不恢复原貌，得到的结果会有重复，并且得到的结果不全。 交换一定要从start开始，而不是start+1， func permute(nums []int) [][]int { var results [][]int backTrace(nums, &results,0) return results } func backTrace(nums []int, results *[][]int, start int){ if start == len(nums){ *results = append(*results,append([]int{},nums...)) } for i := start; i 96. 不同的二叉搜索树 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ TAG：【动态规划】 本题是一维的动态规划算法，构造result[i]代表1～i组成的二叉搜索树的种类。可以知道m~n的二叉搜索树的种类等于1～n-m+1为节点组成的二叉搜索树。又根据二叉搜索树的性质，root左边的数小于root，右边的数大于root。因此，1～i为节点的二叉搜索树的种类是以1～i分别为root时左右两边二叉树种类的乘积。 func numTrees(n int) int { var result = make([]int, n+1) result[0] = 1 result[1] = 1 for i:=2;i153. 寻找旋转排序数组中的最小值 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。你可以假设数组中不存在重复元素。 旋转数组前半部分所有数字值大于后半部分，需要找到旋转点。所以判断一截数组，如果第一个元素大于最后一个元素，说明这截数组仍然是旋转数组。 要判断end-start==1的情况，应为当这种情况下，mid=(start+end)/2会出现mid==start，从而造成死循环。 本题假设没有重复数字，当有重复数字时，会有nums[start] == nums[end]==nums[mid]的情况，这个时候需要顺序查找最小值。 func findMin(nums []int) int { if len(nums) == 0 { return 0 } start, end :=0, len(nums)-1 for nums[start] > nums[end]{ if end -start == 1{ return nums[end] } mid := (start + end)/2 if nums[start] >= nums[mid] { end = mid } else if nums[start] 200. 岛屿数量 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 TAG:【图】【递归】【深度优先】【广度优先】 深度优先搜索：关键词递归 从某个点开始，如果值是1，说明至少有1个岛，岛屿的数量+1. 然后从这个点开始深度优先深度从上下左右四个方向开始深度优先搜索，直到遍历到值是0的点，将之前遍历到的值是1的点改成0. 知道所有点被遍历完为止。 广度优先搜索：关键词队列 与深度优先搜索一样，不同点在于，把当前节点周围值为1的节点都存储下来，依次遍历直到邻接点是0为止。 // 深度优先搜索 func numIslands(grid [][]byte) int { result := 0 for i := 0; i = 0 && (*grid)[x-1][y] == '1' { (*grid)[x-1][y] = '0' dfs(grid, x-1, y) } if x+1 = 0 && (*grid)[x][y-1] == '1' { (*grid)[x][y-1] = '0' dfs(grid, x, y-1) } if y+1 // 广度优先算法 func numIslands(grid [][]byte) int { if len(grid) == 0{ return 0 } result := 0 neigbor := make([]int, 0) row := len(grid) col:=len(grid[0]) for i := 0; i 0{ x,y:=neigbor[0]/col,neigbor[0]%col neigbor = neigbor[1:] if x-1 >= 0 && grid[x-1][y] == '1' { grid[x-1][y] = '0' neigbor = append(neigbor, (x-1)*col+y) } if x+1 = 0 && grid[x][y-1] == '1' { grid[x][y-1] = '0' neigbor = append(neigbor, x*col+y-1) } if y+1 403. 青蛙过河 给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。实例：输入[0,1,3,5,6,8,12,17]，输出true。 TAG：【动态规划】 本题涉及二维的动态规划 dp[i][j] 表示在stones[i]上可以跳跃j步。 当计算到dp[i][j]， i=n-1且存在为true的j时，说明前一个节点也可以跳j步到达这最后一个石头上。 func canCross(stones []int) bool { var dp = make([][]bool, len(stones)) // 在stones[i]上可以跳跃j步 for i := range dp { dp[i] = make([]bool, len(stones)) } dp[0][1] = true for i := 1; i = len(stones) || !dp[j][dis] {continue}// dis的范围判断是为了dp[j][dis]下标不越界 if i == len(stones)-1 {return true} // 成功判定 dp[i][dis] = true // 更新dp数组 if dis-1 > 0 { dp[i][dis-1] = true} if dis+1 698. 划分为k个相等的子集 给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 TAG：【数组】【递归】【动态规划】 func canPartitionKSubsets(nums []int, k int) bool { total := 0 for i := range nums { total += nums[i] } if k = 0; i-- { if nums[i] > sum { return false } if nums[i] == sum { lastIdx-- k-- } if nums[i] 779. 第K个语法符号 在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始） TAG：【数组】【递归】 按照递归2步走：终止条件，递归式。 func kthGrammar(N int, K int) int { if N794. 有效的井字游戏 用字符串数组作为井字游戏的游戏板 board。当且仅当在井字游戏过程中，玩家有可能将字符放置成游戏板所显示的状态时，才返回 true。该游戏板是一个 3 x 3 数组，由字符 \" \"，\"X\" 和 \"O\" 组成。字符 \" \" 代表一个空位。 以下是井字游戏的规则： 玩家轮流将字符放入空位（\" \"）中。 第一个玩家总是放字符 “X”，且第二个玩家总是放字符 “O”。 “X” 和 “O” 只允许放置在空位中，不允许对已放有字符的位置进行填充。 当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。 当所有位置非空时，也算为游戏结束。 如果游戏结束，玩家不允许再放置字符。 TAG：【数组】【二维】 本题就是找规律，分为以下3个特殊情形： X棋子先下，因此X的数量比O多1个，或者与O相等，其他情况说明不符合游戏规则，返回false。 当X满足赢的条件的时候，X数量比O多1，否则返回false。 当O满足赢的条件的时候，O数量和X一样多，否则返回false。 func validTicTacToe(board []string) bool { cntO,cntX:=count(board) if cntX-cntO!= 1 && cntX-cntO!=0{ // 条件1判断 return false } if win(board,'X') && cntX-cntO!=1{ // 条件2判断 return false } if win(board,'O') && cntX!=cntO{ // 条件3判断 return false } return true } func count(board []string)(int,int){ // 获取X和O棋子的个数 var cntO, cntX int for j := 0; j 894. 所有可能的满二叉树 满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。答案中每个树的每个结点都必须有 node.val=0。你可以按任何顺序返回树的最终列表。 TAG：【递归】【树】 递归的思路，N个节点时，根节点占用一个节点，左右子孩子占有N-1个节点，由于是满二叉树，因此如果存在左孩子，必定需要有右孩子，反之亦然。遍历左孩子占用节点树为1～N-2的情况，得出左孩子可能的根节点的数据，将这些根节点接上原始root，则得到了不同的目标答案。 核心在于构建递归函数的入参和出参。理论上，递归函数是可以不设置任何出参的，可以在入参中存储结果。（需要存储结果的原因在于存储下子问题的解，避免重复子问题计算）。由于目标结果是树的头节点的切片[]*TreeNode，因此如果我们需要存在子问题的解，则需要存节点数为1～N范围的结果值，因此，存储结果的类型设置为[][]*TreeNode. func allPossibleFBT(N int) []*TreeNode { if N == 0 { return nil } store := make([][]*TreeNode, N+1) findTree(N, &store) return store[N] } func findTree(N int, store *[][]*TreeNode) { if N == 1 { (*store)[N] = []*TreeNode{&TreeNode{0, nil, nil}} return } result := make([]*TreeNode, 0) for i := 1; i 912. 排序数组 给定一个整数数组 nums，将该数组升序排列。 TAG：【排序】【数组】 快速排序: func quickSort(nums []int){ partition(nums, 0, len(nums)-1) } func partition(nums []int, start, end int){ if start >= end{ return } var i, j = start, end pivot:=nums[start] for i =pivot{ nums[j] = nums[i] j-- break } } } nums[i] = pivot // 置位 partition(nums, start, i-1) // 分治 partition(nums, i+1, end) } 堆排序： func heapSort(nums []int){ for i:=len(nums)/2-1;i>=0;i--{ // 从最后一个非叶子结点开始调整，构造一个完成最大堆 heaplify(nums, i, len(nums)-1) } for j:=len(nums)-1;j>=1;j--{// 将堆定最大元素取出，将堆最后一个叶子结点放在堆定，再调整 nums[0],nums[j] = nums[j],nums[0] heaplify(nums,0,j-1) } } func heaplify(nums []int, start, end int){// 堆的调整 for i := start; inums[i] && (right > end || nums[right]nums[i]{ nums[right],nums[i] = nums[i],nums[right] i=right }else{ break } } } 923. 三数之和的多种可能 给定一个整数数组 A，以及一个整数 target 作为目标值，返回满足 i 【三指针】 由于数字大小范围为0～100，首先采用桶排序，对A数组中的数字出现的次数进行统计，record[i]表示数字i出现的次数，如果没有数字i，则record[i]=0。 定好第一个数，另外两个数分别用首尾指针确定，由于可能出现3个数字中有相同的数的情况，首指针从第一个数的位置开始，首尾指针可以相等。 注意判断特殊情况，第一个数和第二个数相等，第二个数和第三个数相等的情况。 func threeSumMulti(A []int, target int) int { const maxResult = 1000000007 const maxNum = 100 var record = make([]int, maxNum+1) for i := range A { record[A[i]]++ } result := 0 for i := 0; i = j; { if record[j] == 0 || j+k left { k-- continue } if i = 2 { result = (result + ((record[i]*(record[i]-1))/2)*record[k]) % maxResult } else if i = 2 { result = (result + ((record[j]*(record[j]-1))/2)*record[i]) % maxResult } else if record[i] >= 3 { result = (result + ((record[j] * (record[j] - 1) * (record[j] - 2)) / 6)) % maxResult } j++ k-- } } return result } 993. 二叉树的堂兄弟节点 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 TAG：【树】 递归分别求x和y的深度和父节点的值。 func isCousins(root *TreeNode, x int, y int) bool { var xParent, yParent, xdepth, ydepth int xflg:=isChild(root,x,&xParent,&xdepth) yflg:=isChild(root, y,&yParent,&ydepth) if !xflg || !yflg || xParent == yParent || xdepth!=ydepth { return false } return true } func isChild(root *TreeNode, val int, parent *int, depth *int) (bool){ if root == nil { return false} if (root.Left != nil && root.Left.Val== val) || (root.Right != nil && root.Right.Val== val){ *parent = root.Val *depth+=1 return true } if isChild(root.Left, val, parent, depth) || isChild(root.Right, val, parent,depth){ *depth+=1 return true } return false } 1277. 统计全为 1 的正方形子矩阵 给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。 输入：matrix = [ [0,1,1,1], [1,1,1,1], [0,1,1,1] ] 输出：15 解释： 边长为 1 的正方形有 10 个。 边长为 2 的正方形有 4 个。 边长为 3 的正方形有 1 个。 正方形的总数 = 10 + 4 + 1 = 15. 按照边长1～min(row,col)的小正方形的情况，暴力求解。 1278. 分割回文串 III 给你一个由小写字母组成的字符串 s，和一个整数 k。 请你按下面的要求分割字符串： 首先，你可以将 s 中的部分字符修改为其他的小写英文字母。 接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。 请返回以这种方式分割字符串所需修改的最少字符数。 输入：s = \"abc\", k = 2 输出：1 解释：你可以把字符串分割成 \"ab\" 和 \"c\"，并修改 \"ab\" 中的 1 个字符，将它变成回文串。 dp[i][j] = min(dp[i][j],dp[m][j-1]+cost[m+1][i]), m=1...i-1 dp[i][j] 代表字符串s前i个字符分成j个子串需要修改的最少字符数，cost[m][n]代表字符串第m到n个字符的子串变成回文需要修改的最小字符数。（下标均为从1开始） func initCost(s string) [][]int { // cost[i][j]表示第i～j字符段成为回文需要变化的次数，下标0开始 var cost = make([][]int, len(s)) for i := 0; i Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-14 00:46:44 "},"DataStructAndAlgorithm/recursion.html":{"url":"DataStructAndAlgorithm/recursion.html","title":"递归","keywords":"","body":"简介 什么时候用递归？ 可以找到子问题的退出条件。 一个问题可以分解为子问题。 递归的缺点？ 递归的本质是函数调用自身。函数的调用有时间和空间的消耗。 函数递归调用的本质的入栈与出栈操作，调用层次太多时，会导致栈溢出。（函数递归时先将父问题和子问题依次压栈，解决最低层子问题之后，再依次弹栈解决父问题。因此任何用递归解决的问题都可以利用栈改成非递归版本）。 递归中可能存在重复子问题计算。（这一点可以通过存储子问题的结果得以解决） 递归的分类？ 数组的递归 链表的递归 树的递归 数组的递归 最长公共子串 链表的递归 树的递归 894. 所有可能的满二叉树 深度优先 广度优先 图 130 200 参考 一文读懂递归算法 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-08 22:57:56 "},"DataStructAndAlgorithm/dynamicProgram.html":{"url":"DataStructAndAlgorithm/dynamicProgram.html","title":"动态规划","keywords":"","body":"回文字符串 LCS Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-10 22:02:57 "},"DataStructAndAlgorithm/sort.html":{"url":"DataStructAndAlgorithm/sort.html","title":"排序","keywords":"","body":"排序 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-06 07:50:12 "},"DataStructAndAlgorithm/tree.html":{"url":"DataStructAndAlgorithm/tree.html","title":"树","keywords":"","body":"种类 二叉树 满二叉树：每个结点恰有0个或2个子结点。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-08 22:46:52 "},"DataStructAndAlgorithm/bfsDfs.html":{"url":"DataStructAndAlgorithm/bfsDfs.html","title":"DFS & BFS","keywords":"","body":"二叉树的深度优先与广度优先 关于二叉树的深度优先遍历和广度优先遍历： DFS BFS 数据结构 栈 队列 思想 深度优先遍历的思想是从上至下，对每一个分支一直往下一层遍历直到这个分支结束，然后返回上一层，对上一层的右子树这个分支继续深搜，直到一整棵树完全遍历，因此深搜的步骤符合栈后进先出的特点. 广度优先遍历的思想是从左至右，对树的每一层所有结点依次遍历，当一层的结点遍历完全后，对下一层开始遍历，而下一层结点又恰好是上一层的子结点。因此广搜的步骤符合队列先进先出的思想。 优缺点 不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。 保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。 遍历方法 二叉树的深度优先搜索有三种遍历方法：先序遍历：根左右。中序遍历：左根右。后序遍历：左右根。除了利用栈以外，深度优先搜索也可以使用递归的方法。 图的深度优先与广度优先 深度优先遍历(Depth First Search)的主要思想是： 首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点； 当没有未访问过的顶点时，则回到上一个顶点，继续试探别的顶点，直至所有的顶点都被访问过。 广度优先遍历(Depth First Search)的主要思想是：类似于树的层序遍历。 参考： 二叉树的深度优先遍历(DFS)和广度优先遍历(BFS) Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:26:58 "},"DataStructAndAlgorithm/complex.html":{"url":"DataStructAndAlgorithm/complex.html","title":"算法复杂度","keywords":"","body":"圈复杂度 算法复杂度 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:34:26 "},"Database/database.html":{"url":"Database/database.html","title":"数据库","keywords":"","body":"Database 数据库索引 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 00:49:18 "},"DistributionSystem/distributionSystem.html":{"url":"DistributionSystem/distributionSystem.html","title":"分布式系统","keywords":"","body":"微服务 https://mp.weixin.qq.com/s/OAjcQdQxQzTRRv6q52JPNg https://mp.weixin.qq.com/s/mJ_jZZoak7uhItNgnfmZvQ zookeeper redis 强一致性 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-06 12:53:34 "},"DesignPattern/designPattern.html":{"url":"DesignPattern/designPattern.html","title":"设计模式","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:21:05 "},"ComputerNetworks/transportLayer.html":{"url":"ComputerNetworks/transportLayer.html","title":"传输层","keywords":"","body":"三次握手 四次挥手 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:38:32 "}}