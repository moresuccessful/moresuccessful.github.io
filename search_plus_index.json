{"./":{"url":"./","title":"Introduction","keywords":"","body":"Welcome To Moresuccessful Zone! 世上没有白费的努力，成功不必在我，而功力必不唐捐。 ——胡适 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-04 08:54:37 "},"cs/ComputerNetworks/computerNetworks.html":{"url":"cs/ComputerNetworks/computerNetworks.html","title":"计算机网络","keywords":"","body":"计算机网络 计算机网络7层模型 网络分层的意义在于便于管理。 7层模型中，上三层为用户提供服务；下四层为数据传输提供服务，且物理层才是真正用于传输实际数据。 网络层次 协议 功能 数据单位 应用层 HTTP，FTP 1. 用户接口 APDU应用协议数据单元 表示层 1. 将数据翻译成01（英文ASCII，中文GB2312，图片jpg，音频mp3等）。2. 加密、压缩 PPDU表示层协议数据单元 会话层 1. 确定网络数据是否要经过远程会话（如果不需要进行远程传递，则不会发给传输层，而是直接让磁盘储存。） SPDU会话协议数据单元 传输层 TCP,UDP 1. 确定端口号（不同端口号对应不同的服务）2. 确定传输协议可靠/不可靠3. 传输前的错误检测，流控 TPDU 数据段 网络层 1. IP2. ICMP(互联网控制报文协议, ping操作应用此协议)3. IGMP(互联网组管理协议) 1. 提供逻辑地址（IP）、选路 IP数据报文保存IP地址信息 数据链路层 CSMA,CDMA，ARP 1. 成帧2. 用MAC地址访问文件（MAC用于局域网）3. 错误检测与修正4. 采用载波监听多路访问模式 MAC 帧保存了硬件MAC地址 物理层 1. 负责设备之间比特流的传输，物理接口、电气特性等（网线、网卡） 01比特流 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-01 10:00:40 "},"cs/ComputerNetworks/applicationLayer.html":{"url":"cs/ComputerNetworks/applicationLayer.html","title":"应用层","keywords":"","body":"应用层概述 为网络应用（主机上正在运行的进程）提供一个与表示层交互的接口。 协议 基于TCP的应用层协议 HTTP: (Hypertex Transport Protocol, 超文本传输协议 ) 从web服务器传输超文本到本地浏览器。 FTP: (File Transfer Protocol，文件传输协议) 用于下载文件、上传主页，使用21端口。 Telnet: (远端登录协议) 基于DOS模式下的远程连接到计算机的通信服务，使用23端口。 SMTP: (Simple Mail Transmission Protocol, 简单邮件传输协议) 用于发送邮件，使用25端口。 POP3: 用于接收邮件，只要主机有使用POP3协议的程序(e.g. Foxmail/Outlook）就可以收到例如163邮箱的邮件了，使用110端口。 基于UDP的应用层协议 DNS: (Domain Name System, 域名解析服务) 用于将域名（网址）转换为IP地址，使用53号端口。 SNMP: (Simple Network Management System, 简单网络管理协议) 用来管理IP网络的网络节点（服务器、交换机、路由器、HUBs等）。通过SNMP接收随机消息以及事件报告，网络管理系统能获知网络出现的问题，并规划网络增长。SNMP的前身是简单网关监控协议SGMP。（由于网络设备很多，基于UDP的无连接服务就体现出优势），使用161号端口。 TFTP: (Trival File Transfer Protocol, 简单文件传输协议) 。用于客户机和服务器之间简单的开销不大的文件的传输，只能从文件服务器上读写文件，不具备FTP所具有的一些功能，如不能列出目录、不能进行验证，传输8位数据。使用69端口。 HTTP HTTP 请求 http请求报文如下。（图来源CSDN） 请求方法 请求方法的幂等性：一个方法重复执行多次，产生的效果是一样的，那么这个方法就是幂等的。 请求方法的安全性：不会改变资源的方法是安全的，有GET，HEAD，OPTIONS。 HTTP 请求方法有8种： 请求方法 含义 幂等性 GET 完整请求一个资源。不对服务器产生任何影响 是 HEAD 和GET类似，区别在于仅请求响应首部，不需要传输任何实际内容。 是 OPTIONS 返回请求的资源所支持的方法。 是 PUT 上传文件，将实体部分的数据直接替换到服务器的资源上。 是 PATCH 对文件内容做部分修改。 否 POST 提交表单。这种方法会影响服务器。 否 DELETE 删除资源。 是 TRACE 要求目标服务器返回原是的HTTP请求的内容，可用来查看中间服务器对HTTP请求的影响，可用来追踪一个资源请求中间所经过的代理。 HTTP响应 http响应报文如下，包括响应头与响应体两部分。（图来源百度百科） 状态码 状态码（status code）和状态码描述（description）位于HTTP响应报文的响应行（status line）中。 状态类型状态码&描述含义 1XX 信息 1XX是一种临时状态，表示接收了消息，仍在处理中，常用于调试场景。 100 Continue通知客户端部分请求已经被服务端接收，客户端应继续发送请求的剩余部分。 2XX 成功 200 Ok请求成功，报文中包含实体主体。类似于做问答题 204 No Content请求成功，但报文中不包含实体主体。类似于做判断题 206 Partial Content请求GET的资源是服务器资源的一部分，那么响应报文则返回请求的那一部分的资源。例如下载场景的断点续传。 3XX重定向 请求返回301 302 303 时，几乎所有浏览器都会把原先的POST请求改为GET请求。 301 Moved Permanently资源被永久重定向，并返回重定向后的新URL 302 Move Temporarily资源临时重定向，返回临时的URL 303 See Other和302类似，并增加了一个附加条件，需要用GET方法访问临时重定向的URL,且303响应禁止被缓存。 304 Not Modified通知客户端资源未改变，可直接使用本地缓存，且服务端不会返回实体主体（相当于重定向到本地缓存）这种响应通常是请求带有附加条件，如请求一段时间内未变更的资源。 307 Temporary Redirect与302类似，区别在于禁止将POST方法转为GET方法。 4XX客户端错误 客户端出错导致请求无法被处理 400 Bad Request请求中有语法或参数错误 401 Unauthorized请求头中Authorization身份认证字段有误，未授权 403 Forbidden无访问权限，服务器拒绝了请求，具体原因在响应报文实体主体中给出，也可能不给出。 404 Not Found请求的资源未找到 5XX服务端错误 500 Internal Server Error内部服务器故障 502 Bad Gateway作为代理（客户端和服务端的中转，转发双方的请求，使用http协议）或网关（与代理类似，区别在于与源服务器之间可以使用非http协议）的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 Service Unavailable服务器由于维护、升级、过载等原因暂时无法响应 504 Gateway Timeout作为网管或代理的服务器访问超时。 HTTPS cookie v.s. session cookie存储在浏览器上，最大存储量为4KB。session存储在服务器端，大小无限制。 cookie可以轻松访问，但是session不能，因此session更安全。 设置cookie时间可使cookie过期，而删除回话需要执行session destroy操作。 参考 百度百科-HTTP状态码 巧记HTTP状态码 http状态码竟然可以这样记 HTTP请求的完全过程 幂等性的含义和 HTTP请求方法的幂等性 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-03 15:22:09 "},"cs/ComputerNetworks/transportLayer.html":{"url":"cs/ComputerNetworks/transportLayer.html","title":"传输层","keywords":"","body":"三次握手 四次挥手 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:38:32 "},"cs/os/operatingSystem.html":{"url":"cs/os/operatingSystem.html","title":"操作系统","keywords":"","body":"操作系统 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 11:00:37 "},"cs/os/processAndThread.html":{"url":"cs/os/processAndThread.html","title":"X程","keywords":"","body":"进程与线程 进程 线程 定义 进程是指程序在数据集上的一次运行，是系统资源分配和调度的基本单元； 线程是进程的一个实体，是CPU调度的基本单元 资源分配与CPU调度 1. 进程之间不共享资源2. 在没有线程的操作系统中，进程既是资源分配的基本单位，又是调度的基本单位3. 一个进程至少有一个线程，即主线程，也可以有多个线程协同工作 1. 线程并不拥有资源，只是使用他们，进程是资源分配和拥有的基本单元。2. 在有线程的操作系统中，进程是资源分配的基本单位，线程是调度的基本单元3. 线程是指进程内的一条执行线路，或者说是进程中可执行代码的单独单元，它是操作系统的基本调度单元。4. 动态性：线程也是程序在相应数据集上的一次执行，由创建而产生，至撤销而消亡，有其生命周期 组成 进程是PCB（进程管理块）结构与程序和数据的组合 通讯 由于同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核 进程 进程间通信 1）消息队列（Message） 消息队列是消息的链接表。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 2）共享内存 使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 3）管道（Pipe）及有名管道（named pipe） 管道可用于具有亲缘关系进程间的通信（父子进程），有名管道克服了管道没有名字的限制，它还允许无亲缘关系进程间的通信； 4）信号（Signal） 信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身； 5）信号量（semaphore） 资源计数器。主要作为进程间以及同一进程不同线程之间的同步手段。 6）套接口（Socket） 更为一般的进程间通信机制，可用于不同机器之间的进程间通信。 fork() 进程的fork()方法用于产生子进程，产生于系统中没有线程的年代。fork操作会进行4步： 为子进程分类内存块和数据结构； 将父进程的部分数据结构内容复制给子进程； 将子进程加入到系统进程列表中； fork()返回，开始调度器调度。 fork() 在父进程中返回子进程的PID，在子进程中返回0，fork出错时返回-1. 当系统中进程数超过系统上限或内存不足时可能出现fork出错的情形。 线程 线程安全 LINK 管程 协程 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-16 14:44:34 "},"cs/DataStructAndAlgorithm/dataStructAndAlgorithm.html":{"url":"cs/DataStructAndAlgorithm/dataStructAndAlgorithm.html","title":"数据结构与算法","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 10:55:51 "},"cs/DataStructAndAlgorithm/leetcode.html":{"url":"cs/DataStructAndAlgorithm/leetcode.html","title":"Leetcode","keywords":"","body":"目录 42. 缺失的第一个正数 46. 全排列 94. 二叉树的中序遍历 96. 不同的二叉搜索树 102. 二叉树的层次遍历 105. 从前序与中序遍历序列构造二叉树 106. 从中序与后序遍历序列构造二叉树 144. 二叉树的前序遍历 145. 二叉树的后序遍历 153. 寻找旋转排序数组中的最小值 200. 岛屿数量 403. 青蛙过河 698. 划分为k个相等的子集 779. 第K个语法符号 794. 有效的井字游戏 889. 根据前序和后序遍历构造二叉树 894. 所有可能的满二叉树 912. 排序数组 923. 三数之和的多种可能 993. 二叉树的堂兄弟节点 1028. 从先序遍历还原二叉树 1277. 统计全为 1 的正方形子矩阵 1278. 分割回文串 III 1360. 日期之间隔几天 1361. 验证二叉树 42. 缺失的第一个正数 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 与剑指 offer第三题类似，不同之处在于可能出现负数或大于数组长度n的数。对于这样的数跳过即可，对其他1～n的数换到下标0～n-1的位置。如果数组内数据为[1,2,...,n], 那么第一个未出现的正数是n+1，所以第一个未出现的正数范围是1～n+1。 nums[i] == i+1 符合置换条件，不需要交换。 nums[i] == nums[nums[i]-1] 两个交换值相等的情况下，会产生死循环，所以也无需交换，继续下一个。 func firstMissingPositive(nums []int) int { n := len(nums) for i := 0; i n || nums[i] == i+1 || nums[i] == nums[nums[i]-1]){ i++ } if i46. 全排列 给定一个没有重复数字的序列，返回其所有可能的全排列。 TAG：【递归】【回溯】 假设数字序列为[0...n-1],首先是确定第一个数，将序号为0～n-1的数分别与第一个数交换位置。交换完了之后要恢复数组原貌，再确定第二个数，将第二个数后面所有数字和第二个数交换。如此，直到确定了所有数之后就得到了一个结果。 注意这里储存结果的二维数组必须得使用指针，否则结果传不出来。 如果不恢复原貌，得到的结果会有重复，并且得到的结果不全。 交换一定要从start开始，而不是start+1， func permute(nums []int) [][]int { var results [][]int backTrace(nums, &results,0) return results } func backTrace(nums []int, results *[][]int, start int){ if start == len(nums){ *results = append(*results,append([]int{},nums...)) } for i := start; i 96. 不同的二叉搜索树 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ TAG：【动态规划】 本题是一维的动态规划算法，构造result[i]代表1～i组成的二叉搜索树的种类。可以知道m~n的二叉搜索树的种类等于1～n-m+1为节点组成的二叉搜索树。又根据二叉搜索树的性质，root左边的数小于root，右边的数大于root。因此，1～i为节点的二叉搜索树的种类是以1～i分别为root时左右两边二叉树种类的乘积。 func numTrees(n int) int { var result = make([]int, n+1) result[0] = 1 result[1] = 1 for i:=2;i153. 寻找旋转排序数组中的最小值 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。你可以假设数组中不存在重复元素。 旋转数组前半部分所有数字值大于后半部分，需要找到旋转点。所以判断一截数组，如果第一个元素大于最后一个元素，说明这截数组仍然是旋转数组。 要判断end-start==1的情况，应为当这种情况下，mid=(start+end)/2会出现mid==start，从而造成死循环。 本题假设没有重复数字，当有重复数字时，会有nums[start] == nums[end]==nums[mid]的情况，这个时候需要顺序查找最小值。 func findMin(nums []int) int { if len(nums) == 0 { return 0 } start, end :=0, len(nums)-1 for nums[start] > nums[end]{ if end -start == 1{ return nums[end] } mid := (start + end)/2 if nums[start] >= nums[mid] { end = mid } else if nums[start] 200. 岛屿数量 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 TAG:【图】【递归】【深度优先】【广度优先】 深度优先搜索：关键词递归 从某个点开始，如果值是1，说明至少有1个岛，岛屿的数量+1. 然后从这个点开始深度优先深度从上下左右四个方向开始深度优先搜索，直到遍历到值是0的点，将之前遍历到的值是1的点改成0. 知道所有点被遍历完为止。 广度优先搜索：关键词队列 与深度优先搜索一样，不同点在于，把当前节点周围值为1的节点都存储下来，依次遍历直到邻接点是0为止。 // 深度优先搜索 func numIslands(grid [][]byte) int { result := 0 for i := 0; i = 0 && (*grid)[x-1][y] == '1' { (*grid)[x-1][y] = '0' dfs(grid, x-1, y) } if x+1 = 0 && (*grid)[x][y-1] == '1' { (*grid)[x][y-1] = '0' dfs(grid, x, y-1) } if y+1 // 广度优先算法 func numIslands(grid [][]byte) int { if len(grid) == 0{ return 0 } result := 0 neigbor := make([]int, 0) row := len(grid) col:=len(grid[0]) for i := 0; i 0{ x,y:=neigbor[0]/col,neigbor[0]%col neigbor = neigbor[1:] if x-1 >= 0 && grid[x-1][y] == '1' { grid[x-1][y] = '0' neigbor = append(neigbor, (x-1)*col+y) } if x+1 = 0 && grid[x][y-1] == '1' { grid[x][y-1] = '0' neigbor = append(neigbor, x*col+y-1) } if y+1 403. 青蛙过河 给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。实例：输入[0,1,3,5,6,8,12,17]，输出true。 TAG：【动态规划】 本题涉及二维的动态规划 dp[i][j] 表示在stones[i]上可以跳跃j步。 当计算到dp[i][j]， i=n-1且存在为true的j时，说明前一个节点也可以跳j步到达这最后一个石头上。 func canCross(stones []int) bool { var dp = make([][]bool, len(stones)) // 在stones[i]上可以跳跃j步 for i := range dp { dp[i] = make([]bool, len(stones)) } dp[0][1] = true for i := 1; i = len(stones) || !dp[j][dis] {continue}// dis的范围判断是为了dp[j][dis]下标不越界 if i == len(stones)-1 {return true} // 成功判定 dp[i][dis] = true // 更新dp数组 if dis-1 > 0 { dp[i][dis-1] = true} if dis+1 698. 划分为k个相等的子集 给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 TAG：【数组】【递归】【动态规划】 func canPartitionKSubsets(nums []int, k int) bool { total := 0 for i := range nums { total += nums[i] } if k = 0; i-- { if nums[i] > sum { return false } if nums[i] == sum { lastIdx-- k-- } if nums[i] 779. 第K个语法符号 在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始） TAG：【数组】【递归】 按照递归2步走：终止条件，递归式。 func kthGrammar(N int, K int) int { if N794. 有效的井字游戏 用字符串数组作为井字游戏的游戏板 board。当且仅当在井字游戏过程中，玩家有可能将字符放置成游戏板所显示的状态时，才返回 true。该游戏板是一个 3 x 3 数组，由字符 \" \"，\"X\" 和 \"O\" 组成。字符 \" \" 代表一个空位。 以下是井字游戏的规则： 玩家轮流将字符放入空位（\" \"）中。 第一个玩家总是放字符 “X”，且第二个玩家总是放字符 “O”。 “X” 和 “O” 只允许放置在空位中，不允许对已放有字符的位置进行填充。 当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。 当所有位置非空时，也算为游戏结束。 如果游戏结束，玩家不允许再放置字符。 TAG：【数组】【二维】 本题就是找规律，分为以下3个特殊情形： X棋子先下，因此X的数量比O多1个，或者与O相等，其他情况说明不符合游戏规则，返回false。 当X满足赢的条件的时候，X数量比O多1，否则返回false。 当O满足赢的条件的时候，O数量和X一样多，否则返回false。 func validTicTacToe(board []string) bool { cntO,cntX:=count(board) if cntX-cntO!= 1 && cntX-cntO!=0{ // 条件1判断 return false } if win(board,'X') && cntX-cntO!=1{ // 条件2判断 return false } if win(board,'O') && cntX!=cntO{ // 条件3判断 return false } return true } func count(board []string)(int,int){ // 获取X和O棋子的个数 var cntO, cntX int for j := 0; j 894. 所有可能的满二叉树 满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。答案中每个树的每个结点都必须有 node.val=0。你可以按任何顺序返回树的最终列表。 TAG：【递归】【树】 递归的思路，N个节点时，根节点占用一个节点，左右子孩子占有N-1个节点，由于是满二叉树，因此如果存在左孩子，必定需要有右孩子，反之亦然。遍历左孩子占用节点树为1～N-2的情况，得出左孩子可能的根节点的数据，将这些根节点接上原始root，则得到了不同的目标答案。 核心在于构建递归函数的入参和出参。理论上，递归函数是可以不设置任何出参的，可以在入参中存储结果。（需要存储结果的原因在于存储下子问题的解，避免重复子问题计算）。由于目标结果是树的头节点的切片[]*TreeNode，因此如果我们需要存在子问题的解，则需要存节点数为1～N范围的结果值，因此，存储结果的类型设置为[][]*TreeNode. func allPossibleFBT(N int) []*TreeNode { if N == 0 { return nil } store := make([][]*TreeNode, N+1) findTree(N, &store) return store[N] } func findTree(N int, store *[][]*TreeNode) { if N == 1 { (*store)[N] = []*TreeNode{&TreeNode{0, nil, nil}} return } result := make([]*TreeNode, 0) for i := 1; i 912. 排序数组 给定一个整数数组 nums，将该数组升序排列。 TAG：【排序】【数组】 快速排序: func quickSort(nums []int){ partition(nums, 0, len(nums)-1) } func partition(nums []int, start, end int){ if start >= end{ return } var i, j = start, end pivot:=nums[start] for i =pivot{ nums[j] = nums[i] j-- break } } } nums[i] = pivot // 置位 partition(nums, start, i-1) // 分治 partition(nums, i+1, end) } 堆排序： func heapSort(nums []int){ for i:=len(nums)/2-1;i>=0;i--{ // 从最后一个非叶子结点开始调整，构造一个完成最大堆 heaplify(nums, i, len(nums)-1) } for j:=len(nums)-1;j>=1;j--{// 将堆定最大元素取出，将堆最后一个叶子结点放在堆定，再调整 nums[0],nums[j] = nums[j],nums[0] heaplify(nums,0,j-1) } } func heaplify(nums []int, start, end int){// 堆的调整 for i := start; inums[i] && (right > end || nums[right]nums[i]{ nums[right],nums[i] = nums[i],nums[right] i=right }else{ break } } } 923. 三数之和的多种可能 给定一个整数数组 A，以及一个整数 target 作为目标值，返回满足 i 【三指针】 由于数字大小范围为0～100，首先采用桶排序，对A数组中的数字出现的次数进行统计，record[i]表示数字i出现的次数，如果没有数字i，则record[i]=0。 定好第一个数，另外两个数分别用首尾指针确定，由于可能出现3个数字中有相同的数的情况，首指针从第一个数的位置开始，首尾指针可以相等。 注意判断特殊情况，第一个数和第二个数相等，第二个数和第三个数相等的情况。 func threeSumMulti(A []int, target int) int { const maxResult = 1000000007 const maxNum = 100 var record = make([]int, maxNum+1) for i := range A { record[A[i]]++ } result := 0 for i := 0; i = j; { if record[j] == 0 || j+k left { k-- continue } if i = 2 { result = (result + ((record[i]*(record[i]-1))/2)*record[k]) % maxResult } else if i = 2 { result = (result + ((record[j]*(record[j]-1))/2)*record[i]) % maxResult } else if record[i] >= 3 { result = (result + ((record[j] * (record[j] - 1) * (record[j] - 2)) / 6)) % maxResult } j++ k-- } } return result } 993. 二叉树的堂兄弟节点 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 TAG：【树】 递归分别求x和y的深度和父节点的值。 func isCousins(root *TreeNode, x int, y int) bool { var xParent, yParent, xdepth, ydepth int xflg:=isChild(root,x,&xParent,&xdepth) yflg:=isChild(root, y,&yParent,&ydepth) if !xflg || !yflg || xParent == yParent || xdepth!=ydepth { return false } return true } func isChild(root *TreeNode, val int, parent *int, depth *int) (bool){ if root == nil { return false} if (root.Left != nil && root.Left.Val== val) || (root.Right != nil && root.Right.Val== val){ *parent = root.Val *depth+=1 return true } if isChild(root.Left, val, parent, depth) || isChild(root.Right, val, parent,depth){ *depth+=1 return true } return false } 1277. 统计全为 1 的正方形子矩阵 给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。 输入：matrix = [ [0,1,1,1], [1,1,1,1], [0,1,1,1] ] 输出：15 解释： 边长为 1 的正方形有 10 个。 边长为 2 的正方形有 4 个。 边长为 3 的正方形有 1 个。 正方形的总数 = 10 + 4 + 1 = 15. 按照边长1～min(row,col)的小正方形的情况，暴力求解。 1278. 分割回文串 III 给你一个由小写字母组成的字符串 s，和一个整数 k。 请你按下面的要求分割字符串： 首先，你可以将 s 中的部分字符修改为其他的小写英文字母。 接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。 请返回以这种方式分割字符串所需修改的最少字符数。 输入：s = \"abc\", k = 2 输出：1 解释：你可以把字符串分割成 \"ab\" 和 \"c\"，并修改 \"ab\" 中的 1 个字符，将它变成回文串。 dp[i][j] = min(dp[i][j],dp[m][j-1]+cost[m+1][i]), m=1...i-1 dp[i][j] 代表字符串s前i个字符分成j个子串需要修改的最少字符数，cost[m][n]代表字符串第m到n个字符的子串变成回文需要修改的最小字符数。（下标均为从1开始） func initCost(s string) [][]int { // cost[i][j]表示第i～j字符段成为回文需要变化的次数，下标0开始 var cost = make([][]int, len(s)) for i := 0; i 1360. 日期之间隔几天 日期以字符串形式给出，格式为 YYYY-MM-DD, 判断两个日期之间隔了多少天。例如输入：date1 = \"2019-06-29\", date2 = \"2019-06-30\" 。输出：1。 方法一：可以利用go的time包，使用time.Data函数将数据转成time.Time类型，再利用time.Time的Sub方法计算时间差。 方法二：自己实现类似uinx time的功能，即以某个时间点T为基准，判断t1和t2分别距离T有多少天，再求天数的差值。 func daysBetweenDates(date1 string, date2 string) int { } Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-27 23:30:42 "},"cs/DataStructAndAlgorithm/tree.html":{"url":"cs/DataStructAndAlgorithm/tree.html","title":"树","keywords":"","body":"二叉树分类 满二叉树：每个结点恰有0个或2个子结点。 搜索二叉树： 左叶子 二叉树的遍历 树的遍历方式分为深度优先搜索遍历（DFS）与宽度优先搜索遍历（BFS）。 DFS采用深度作为优先级，从根开始一直遍历到某一确定节点，再返回根到达另外一个分支。DFS又可以根据树的根节点遍历的顺序分为前序遍历，中序遍历与后序遍历。二叉树的遍历还涉及根据遍历结果重建二叉树, 验证有效二叉树。 BSF按照高度层次逐层遍历树，层次高的节点优先于层次低的的节点被遍历。BFS包含树的层序遍历 DFS 前序遍历 设置一个栈nodeSaver一次存储根节点、右节点、左节点。 下一次遍历，栈顶弹出上一次的左节点Left，并继续压栈Left的右、左节点。 如此，先遍历了根和左节点，最后遍历右节点。 func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } nodeSaver, res := []*TreeNode{root}, []int{} // 栈初始化 for len(nodeSaver) > 0 { curNode := nodeSaver[len(nodeSaver)-1] nodeSaver = nodeSaver[:len(nodeSaver)-1] // 根节点出栈 res = append(res, curNode.Val) if curNode.Right != nil { nodeSaver = append(nodeSaver, curNode.Right) // 右节点压栈 } if curNode.Left != nil { nodeSaver = append(nodeSaver, curNode.Left) // 左节点压栈 } } return res } 中序遍历 设置一个栈用于存储当前节点往下遍历的所有的根和左子树的节点。 当当前节点遍历到末端（nil）时，开始弹栈，依次将左子树和根弹出，最后随后当前根节点的右叶子。 func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } var nodeSaver []*TreeNode var res []int for cur := root; cur != nil || len(nodeSaver) > 0; { for cur != nil { nodeSaver = append(nodeSaver, cur) // 当前节点向下的所有根、左叶子压栈 cur = cur.Left } cur = nodeSaver[len(nodeSaver)-1] nodeSaver = nodeSaver[:len(nodeSaver)-1] // 左叶子/根出栈 res = append(res, cur.Val) cur = cur.Right // 处理右叶子 } return res } 后序遍历 方法与前序遍历类似，前序遍历的顺序是根左右；后序顺序是左右根，后序结果逆序之后是根右左。 因此设置节点压栈顺序是根、左、右，存储结果的时候，需要把当前节点的值放在前面（即结果需要逆序） func postorderTraversal(root *TreeNode) []int { if root == nil{ return nil } nodeSaver, res := []*TreeNode{root}, []int{} // 栈初始化 for len(nodeSaver) > 0 { cur := nodeSaver[len(nodeSaver)-1] nodeSaver = nodeSaver[:len(nodeSaver)-1] // 根节点出栈 res = append([]int{cur.Val}, res...) // 结果逆序存储 if cur.Left != nil{ nodeSaver = append(nodeSaver, cur.Left) // 左节点压栈 } if cur.Right!= nil{ nodeSaver = append(nodeSaver, cur.Right) // 右节点压栈 } } return res } 重建二叉树 两种遍历序列可以确定二叉树的结构，但当且仅当其中一种遍历方式是中序遍历时，才能唯一确定一个二叉树结构。 由前中序构造二叉树, 由中后序构造二叉树 可以构造一棵唯一的二叉树；仅由前后序构造二叉树可以构造多种二叉树；由变种的前序遍历可以恢复二叉树。 翻转二叉树以匹配先序遍历 由前中序构造二叉树 采用递归,下面算法的前提是树中没有重复元素。前序遍历第一个节点是根节点，在中序遍历中找到根节点的位置，前半部分则是根的左叶子，后半部分是根的右叶子。 func buildTree(preorder []int, inorder []int) *TreeNode { if a, b := len(preorder), len(inorder); a != b || a == 0{ return nil } root:=&TreeNode{preorder[0],nil,nil} idx := 0 for i := range inorder{ if inorder[i] == preorder[0]{ idx = i break } } root.Left = buildTree(preorder[1:idx+1],inorder[:idx]) root.Right = buildTree(preorder[idx+1:],inorder[idx+1:]) return root } 由中后序构造二叉树 几乎与由前中序构造二叉树解法完全一致，使用递归即可。 func buildTree(inorder []int, postorder []int) *TreeNode { if a,b := len(inorder), len(postorder); a != b || a == 0 { return nil } rootVal:=postorder[len(postorder)-1] var idx int for idx=0;idx由前后序构造二叉树 前序和后序遍历不能唯一确定一个二叉树结构，下面算法给出了可能的一种二叉树。 前序的第一个节点和后序的最后一个节点是根节点，据此得出递归后的pre和post入参。 func constructFromPrePost(pre []int, post []int) *TreeNode { if a, b := len(pre), len(post); a != b || a == 0{ return nil } root := &TreeNode{Val:pre[0]} if len(pre) == 1{ return root } next := pre[1] // 下一个根节点 var idx int for idx = 0; idx从变种先序遍历还原二叉树 我们从二叉树的根节点 root 开始进行深度优先搜索。在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。如果节点只有一个子节点，那么保证该子节点为左子节点。给出遍历输出 S，还原树并返回其根节点 root。例：输入：\"1-2--3--4-5--6--7\" 输出： 1 / \\ 2 5 / \\ / \\ 3 4 6 7 定义了slashCount来定义数字A前面的横杠的个数。这个个数其实就代表了数字A在二叉树种的层次。（根节点是第0层）。由于使用Split函数会吞掉一个横杠，所以初始化的时候设置slashCount为1，补齐吞掉的横杠。 nodeSave中存的节点，由于是前序遍历，所以可以保证任何时刻，nodeSave中存的节点，每层二叉树只有1个。所以每次在处理一个新节点之前，前将多余的左叶子节点去掉，只保留nodeSave当前层以上的节点。 func recoverFromPreorder(S string) *TreeNode { if len(S) == 0 {return nil} splitSeg := strings.Split(S, \"-\") rootVal, _ := strconv.Atoi(splitSeg[0]) root := &TreeNode{Val: rootVal} // 第一个元素是根 slashCount, nodeSaver := 1, []*TreeNode{root} for i := 1; i 翻转二叉树以匹配先序遍历 给定一个有 N 个节点的二叉树，每个节点都有一个不同于其他节点且处于 {1, ..., N} 中的值。通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。我们的目标是翻转最少的树中节点，以便树的前序遍历行程与给定的行程 voyage 相匹配。 如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表 [-1]。例如：输入二叉树 1 /\\ 2 3 voyage=[1,3,2], 则输出 [1] func flipMatchVoyage(root *TreeNode, voyage []int) []int { var idx = 0 return flipMatchVoyagePreSearch(root,voyage,&idx) } func flipMatchVoyagePreSearch(root *TreeNode, voyage []int, idx *int)[]int{ var res []int if root == nil && *idx >= len(voyage) { return []int{-1} } if (root == nil && *idx = len(voyage) || root.Val != voyage[*idx])){ return []int{-1} } if *idx+1验证二叉树 二叉树上有 n 个节点，按从 0 到 n - 1 编号，其中节点 i 的两个子节点分别是 leftChild[i] 和 rightChild[i]。只有 所有 节点能够形成且只形成一颗有效的二叉树时，返回 true；否则返回 false。如果节点 i 没有左子节点，那么 leftChild[i] 就等于 -1。右子节点也符合该规则。例如：   0  / \\ 1  2    /   3 输入： n=4, leftChild=[1,-1,3,-1], rightChild=[2,-1,-1,-1], 输出：true 要点在于首先要找到根节点，根节点的特征是入度为0。 从根节点开始深度优先遍历，当遍历到叶子时，如果仍存在有节点没有被遍历到，那么就说明不是一棵有效的二叉树。 func validateBinaryTreeNodes(n int, leftChild []int, rightChild []int) bool { var ingree = make([]int,n) for i:=range leftChild{ // 计算入度 if leftChild[i]!= -1{ ingree[leftChild[i]]++ } if rightChild[i]!=-1{ ingree[rightChild[i]]++ } } var root int for i:=range ingree{ // 寻找根节点 if ingree[i]==0{ root = i break } } seen:=make([]bool,n) // 标记是否所有节点都被遍历到 seen[root] =true return dfs(root,leftChild,rightChild,seen) && visit(seen) } func visit(seen []bool)bool{ // 判断是否所有节点都被遍历到 for i:=range seen{ if !seen[i]{ return false } } return true } func dfs(root int,leftChild []int, rightChild []int, seen []bool)bool{ if root==-1{ return true } leftFlg:=true if leftChild[root]!= -1 { if seen[leftChild[root]]{ // 节点已经被遍历，则说明不是一颗有效二叉树 return false } seen[leftChild[root]]=true leftFlg = dfs(leftChild[root],leftChild,rightChild,seen) } rightFlg:=true if rightChild[root]!=-1{ if seen[rightChild[root]]{ return false } seen[rightChild[root]]=true rightFlg = dfs(rightChild[root],leftChild,rightChild,seen) } return leftFlg&&rightFlg } BFS 层序遍历 当层序遍历的结果只需要存在一维数组中时，只需要一个一维数组存储树的节点，一直往后面追加节点即可。 有的层序遍历，如下面代码，当结果需要存到二维数组中，即每一层元素单独一个一维数组时，则需要一个二维数组存储树的节点，并用curIdx记录当前层。这里要注意容易错的点是，删除slice第一个元素的时候，不能使用arr = append(arr, arr[1:]...), 这样并不是从头开始append，所以并不会删除第一个元素，反而arr的元素一直在增加。直接arr = arr[1:]即可。(微软2019二面面试题，就是在这个地方错了) func levelOrder(root *TreeNode) [][]int { if root == nil { return nil } curIdx := 0 nodeSaver, curLayer, res := [2][]*TreeNode{{root}, {}}, []int{}, [][]int{} for len(nodeSaver[curIdx]) > 0 { curNode := nodeSaver[curIdx][0] curLayer = append(curLayer, curNode.Val) if curNode.Left != nil { nodeSaver[1-curIdx] = append(nodeSaver[1-curIdx], curNode.Left) } if curNode.Right != nil { nodeSaver[1-curIdx] = append(nodeSaver[1-curIdx], curNode.Right) } nodeSaver[curIdx] = nodeSaver[curIdx][1:] // 删除第一个元素，容易出错 if len(nodeSaver[curIdx]) == 0 { res = append(res, curLayer) curLayer = make([]int, 0) // curLayer 存储当前层的元素 curIdx = 1 - curIdx } } return res } Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-25 22:48:38 "},"cs/DataStructAndAlgorithm/string.html":{"url":"cs/DataStructAndAlgorithm/string.html","title":"字符串","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-08 10:28:13 "},"cs/DataStructAndAlgorithm/sort.html":{"url":"cs/DataStructAndAlgorithm/sort.html","title":"排序","keywords":"","body":"排序 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-06 07:50:12 "},"cs/DataStructAndAlgorithm/recursion.html":{"url":"cs/DataStructAndAlgorithm/recursion.html","title":"递归","keywords":"","body":"简介 什么时候用递归？ 可以找到子问题的退出条件。 一个问题可以分解为子问题。 递归的缺点？ 递归的本质是函数调用自身。函数的调用有时间和空间的消耗。 函数递归调用的本质的入栈与出栈操作，调用层次太多时，会导致栈溢出。（函数递归时先将父问题和子问题依次压栈，解决最低层子问题之后，再依次弹栈解决父问题。因此任何用递归解决的问题都可以利用栈改成非递归版本）。 递归中可能存在重复子问题计算。（这一点可以通过存储子问题的结果得以解决） 递归的分类？ 数组的递归 链表的递归 树的递归 数组的递归 最长公共子串 链表的递归 树的递归 894. 所有可能的满二叉树 深度优先 广度优先 图 130 200 参考 一文读懂递归算法 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-08 22:57:56 "},"cs/DataStructAndAlgorithm/dynamicProgram.html":{"url":"cs/DataStructAndAlgorithm/dynamicProgram.html","title":"动态规划","keywords":"","body":"回文字符串 LCS Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-10 22:02:57 "},"cs/DataStructAndAlgorithm/bfsDfs.html":{"url":"cs/DataStructAndAlgorithm/bfsDfs.html","title":"DFS & BFS","keywords":"","body":"二叉树的深度优先与广度优先 关于二叉树的深度优先遍历和广度优先遍历： DFS BFS 数据结构 栈 队列 思想 深度优先遍历的思想是从上至下，对每一个分支一直往下一层遍历直到这个分支结束，然后返回上一层，对上一层的右子树这个分支继续深搜，直到一整棵树完全遍历，因此深搜的步骤符合栈后进先出的特点. 广度优先遍历的思想是从左至右，对树的每一层所有结点依次遍历，当一层的结点遍历完全后，对下一层开始遍历，而下一层结点又恰好是上一层的子结点。因此广搜的步骤符合队列先进先出的思想。 优缺点 不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。 保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。 遍历方法 二叉树的深度优先搜索有三种遍历方法：先序遍历：根左右。中序遍历：左根右。后序遍历：左右根。除了利用栈以外，深度优先搜索也可以使用递归的方法。 图的深度优先与广度优先 深度优先遍历(Depth First Search)的主要思想是： 首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点； 当没有未访问过的顶点时，则回到上一个顶点，继续试探别的顶点，直至所有的顶点都被访问过。 广度优先遍历(Depth First Search)的主要思想是：类似于树的层序遍历。 参考： 二叉树的深度优先遍历(DFS)和广度优先遍历(BFS) Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:26:58 "},"cs/DataStructAndAlgorithm/complex.html":{"url":"cs/DataStructAndAlgorithm/complex.html","title":"算法复杂度","keywords":"","body":"圈复杂度 算法复杂度 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:34:26 "},"cs/go/Golang.html":{"url":"cs/go/Golang.html","title":"其他","keywords":"","body":"Golang 学习链接： Golang github Effective Go 中文 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-17 19:07:30 "},"cs/go/gocmd.html":{"url":"cs/go/gocmd.html","title":"命令行操作","keywords":"","body":"命令行 go命令行可参考go源码注释文档src/cmd/go/alldocs.go 编译链接 http://c.biancheng.net/view/120.html Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-20 22:38:34 "},"cs/go/gobasic.html":{"url":"cs/go/gobasic.html","title":"基础","keywords":"","body":"import go通过packet定义包的名称，同一路径下文件的包名必须统一, 建议包名和路径名一致。 go通过import包所在的路径获取包内容，建议填写绝对路径。 import时写路径名，引用时写包名。 import操作 点操作 例如import .\"fmt\"，那么在使用打印函数时，不需要fmt.Println(\"hello\"), 可以省略写成Println(\"hello\")。 别名操作 例如 import f \"fmt\"，将fmt包设置一个别名f，则在使用打印函数时，可以写成f.Println(\"hello\"). 下划线操作 目的是为了调用包中的init函数，而不使用包中的其他方法。例如 import _\"github.com/xxx\" modules https://juejin.im/post/5c8e503a6fb9a070d878184a https://github.com/golang/go/wiki/Modules 参考文献: https://www.cnblogs.com/qiang-cnblog/p/7819587.html main main函数所在包必须为main包 一个包内最多只能有一个main方法。（这是显然的，因为在包作用域内，变量或函数名称都应当是唯一的。） main函数不能带参数，没有返回值。 main函数可以通过调用flag包解析命令行参数。 switch 条件表达式可以为空，则默认为true 单个case中，可以出现多个匹配项，例如 case 1,2,3: 每个case结束，不需要用break退出一个case。可以使用falltrough关键字，执行紧跟着的下一个case。 go buildin method make 用于slice, map, channel, 分配内存并初始化，返回类型的引用（不是指针）。 使用细则 Call | Type T | Result -----|--------|------- make(T,n) | slice | 创建len，cap 均为 n 的 slice make(T,n,m) | slice | 创建 len 为 n, cap 为 m 的slice make(T) | map | 创建map make(T,n) | map | 创建含有n个初值的map make（T）| channel | 无缓存的channel make（T,n） | channel | 缓存大小为 n 的 channel 举例 slice1 := make([]int, 5) map1 := make(map[string]int,5) fmt.Println(slice1). //[0 0 0 0 0] 4.2. new 返回类型的指针。 举例 pslice1 := new([]int) fmt.Println(pslice) //&[0 0] 4.3. len 适用于array，slice, map, string, channel。 举例 fmt.Println(len(slice1)) cap 适用于 array，slice，channel 4.4. append 适用于slice。append超过slice的容量时，slice会自动扩容。 用法 slice = append(slice, elem1, elem2, ...) slice = append(slice, anotherSlice) 举例 slice1 = append(slice1,1) slice1 = append(slice1,slice2) 4.5. delete 适用于map，按指定键删除map对应的元素,当元素不存在时，不进行操作。 用法 delete(map,key) 举例delete(map1,\"Mike\") 参考文档： https://blog.csdn.net/uudou/article/details/52241534 print 格式化 go fmt详细说明LINK %U unicode字符输出，格式同 \"U+%04X\" go defer 功能 将函数推迟到外层函数返回后执行。\b 注意：推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。 例： func testf(a *int){ defer fmt.Println(\"testf1:\",*a) *a=100 fmt.Println(\"testf2:\",*a) } func main(){ a:=10 defer fmt.Println(\"1:\",a) testf(&a) fmt.Println(\"2:\",a) } 输出结果： testf2:100 testf1:10 2:100 1:10 使用陷阱 go panic 错误是业务过程的一部分，而异常不是。 go vet 功能 go vet 是go tool套件的一部分，用于代码静态检查,在代码编译与运行阶段发现bug，废弃代码等。 使用方法 go tool vet 或 go vet go vet 与go tool vet go vet，只在一个单独的包内可用，不能使用flag 选项（来激活某些指定的检测）。 go tool vet更加完整，它可用用于文件和目录。目录被递归遍历来找到包。go tool vet也可以按照检测的分组激活选项。 （可以打开一个终端，比较go vet --help 和go tool vet --help两个命令的不同。） 参考文献 https://studygolang.com/articles/9619 go convey 功能 goconvey是一个支持golang的单元测试框架 goconvey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面 goconvey提供了丰富的断言简化测试用例的编写 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-28 08:12:09 "},"cs/go/godata.html":{"url":"cs/go/godata.html","title":"数据","keywords":"","body":"数据 rune byte == int8，用于处理ascii字符 rune == int32，用于处理unicode或utf-8字符 中文字符在utf-8下占3字节。 https://juejin.im/post/5b44caebf265da0f491b8b83 slice 格式 go语言编译器会自动在以标识符、数字字面量、字母字面量、字符串字面量、特定的关键字（break、continue、fallthrough和return）、增减操作符（++和--）、或者一个右括号、右方括号和右大括号（即)、]、}）结束的非空行的末尾自动加上分号。 因此slice 正确的赋值如下： a1 := []int{ 1,2,3, } a2 := []int{ 1,2,3} 如下赋值方法是错误的 //错误的赋值方法 a3 := []int{ 1,2,3 } 二维数组的排序 可以重新实现sort接口实现，需要实现Len, Less, Swap这三个方法,之后调用sort.Sort函数即可。具体如下。 // 实现接口 type Arrays [][]int func(e Arrays)Len()int{ return len(e) } func(e Arrays)Swap(i,j int){ e[i],e[j]=e[j],e[i] } func(e Arrays)Less(i,j int)bool{ return e[i][0]go map 声明与初始化 声明 var null_map map[string]int 此时，map变量仅被声明了，未被初始化。未初始化的map值为nil，当map未被初始化就被设置元素值时会引起panic。 初始化 map1 := make(map[string]int,5) //初始化容量为5的map map2 := make(map[string]int) map3 := map[string]int{} map4 := map[string]int{1,2,3,4,5} map在初始化时，是否指定初始容量差别不大。当map容量不够时会自动扩容。 遍历 for k,v := range map1{ //... } for k := range map2{ //... } go map的遍历是随机、无序的。 增删改查 map1 := make(map[string]int) map1[\"a\"] = 1 //增加元素 map1[\"a\"] = 0 //修改元素 delete(map1,\"a\") //删除元素 if val, ok := map1[key]; ok{ //查找元素 //...key元素存在... } map的删除使用内置函数delete，该函数没有返回值。当删除的元素不存在时，delete不会做任何操作。 查找操作时，返回两个值，分别是索引key对应的val，与本次索引是否成功。 比较两个map是否相等，需要遍历比较它们的键值对是否完全相等。 > 参考文献 https://blog.csdn.net/xiangxianghehe/article/details/78790744 interface 与 reflect reflect 性能 interface{}是可以指向任意对象的Any类型。 一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理 类实现接口时，需要导入接口所在的包 接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口 方法 go中没有类，可以通过为结构体类型定义方法实现类的功能。 只能为在同一包内定义的类型声明方法，不能为在其他包内定义的类型以及内建类型（如int）等声明方法。 方法接收者类型为指针接收者的优点（对比值类型接收者）： 方法能够修改接收者指向的值； 避免每次在调用方法时复制该值，若值的类型为大型结构体时，将接收者类型设置为指针类型会更高效。S Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-21 08:18:59 "},"cs/go/gobufio.html":{"url":"cs/go/gobufio.html","title":"输入输出","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-17 18:48:39 "},"cs/go/goconcurrency.html":{"url":"cs/go/goconcurrency.html","title":"并发","keywords":"","body":"并发 携程 channel 底层实现 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-17 18:54:19 "},"cs/go/goEngineer.html":{"url":"cs/go/goEngineer.html","title":"工程","keywords":"","body":"工程 代码依赖 vendor gradlew Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-17 18:57:40 "},"cs/go/godebug.html":{"url":"cs/go/godebug.html","title":"Debug","keywords":"","body":"GO Debug Go 调试的方式有很多种，包括通用的Rubber duck debugging, 打印，古早的GDB（适合CGO项目的调试），以及go专属的调试工具delve。此外，golang 提供了一种可以进行Google Analytics(GA)用户活动追踪的第三方库ogle. 打印 这里主要介绍第三方库go-spew。 go-spew go的第三方库go-spew对go的原始打印方法进行了封装，可以打印出数据的详细数据结构、地址(如果是指针类型)、值内容，用于go的debug。🔗GoDoc1,🔗GoDoc2. go-spew 提供了诸如spew.Dump 以及spew.Println等方法。 快速开始： import \"github.com/davecgh/go-spew/spew\" type stru struct{ i int } func main(){ var a=100 var b=stru{200} var c=&stru{200} spew.Dump(a) spew.Dump(b) spew.Dump(c) } 输出结果： (int) 100 (main.stru) { i: (int) 200 } (*main.stru)(0xc0000161b0)({ i: (int) 200 }) delve dlv debug xx.go (dlv)b package.func 设置断点 (dlv)c 继续 continue (dlv)n 下一步 （dlv）s 进入函数 step （dlv）stepout 跳出函数 (dlv) p varname 打印 (dlv)set val (dlv)cal func (dlv)config -list (dlv)help dwarf 二进制调试数据 dwarf dwarf gp build -ldflags=-w dlv debug dlv test Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-18 22:47:49 "},"cs/go/goTest.html":{"url":"cs/go/goTest.html","title":"测试","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-17 18:59:37 "},"cs/go/goperform.html":{"url":"cs/go/goperform.html","title":"性能","keywords":"","body":"性能与调试 pprof 预备工作 安装graphviz. 在终端输入下列命令下载即可。 $ brew install graphviz 性能分析 性能分析分为两种应用场景： 临时测试，一次测试结束后即可。这种方式采用\"runtime/pprof\"包，会将性能数据写入一个文件。 程序持续性在运行。 临时测试 在main 函数处加上下面语句 import \"runtime/pprof\" var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to file\") func main(){ flag.Parse() if *cpuprofile != \"\" { f, err := os.Create(*cpuprofile) if err != nil { log.Fatal(err) } pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() } // your code } web 需要设置svg的默认打开程序是浏览器。 会自动打开 go tool pprof --http=:8080 mem.prof 持续测试 热点图 Go 语言的高级调试方法 视频 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-22 17:15:02 "},"cs/go/goOthers.html":{"url":"cs/go/goOthers.html","title":"其他","keywords":"","body":"Golang 优缺点 优点 并发 connection pooling 缺点 适用场景 Golang C/C++ Java Python go marshal 代码规范 github CodeReview Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-17 19:08:11 "},"cs/db/database.html":{"url":"cs/db/database.html","title":"数据库","keywords":"","body":"Database 数据库索引 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 00:49:18 "},"cs/DistributionSystem/distributionSystem.html":{"url":"cs/DistributionSystem/distributionSystem.html","title":"分布式系统","keywords":"","body":"微服务 https://mp.weixin.qq.com/s/OAjcQdQxQzTRRv6q52JPNg https://mp.weixin.qq.com/s/mJ_jZZoak7uhItNgnfmZvQ zookeeper redis 强一致性 秒杀系统 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-15 08:06:58 "},"cs/DesignPattern/designPattern.html":{"url":"cs/DesignPattern/designPattern.html","title":"设计模式","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:21:05 "},"cs/Logic/logic.html":{"url":"cs/Logic/logic.html","title":"智力题","keywords":"","body":"查找 赛马次数 有 25 匹马和 5 条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前 3 名。 先把 25 匹马分成 5 组，进行 5 场赛马，得到每组的排名。再将每组的第 1 名选出，进行 1 场赛马，按照这场的排名将 5 组先后标为 A、B、C、D、E。可以知道，A 组的第 1 名就是所有 25 匹马的第 1 名。而第 2、3 名只可能在 A 组的 2、3 名，B 组的第 1、2 名，和 C 组的第 1 名，总共 5 匹马，让这 5 匹马再进行 1 场赛马，前两名就是第 2、3 名。所以总共是 5+1+1=7 场赛马。 A 组：1，2，3，4，5 B 组：1，2，3，4，5 C 组：1，2，3，4，5 D 组：1，2，3，4，5 E 组：1，2，3，4，5 九球称重 有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。 将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。 对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。 药丸称重 有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。 可以从药丸的数量上来制造差异：从第 i 瓶药丸中取出 i 个药丸，然后一起称重。可以知道，如果第 i 瓶药丸重 1.1 克/粒，那么称重结果就会比正常情况下重 0.1 * i 克。 扔鸡蛋 todo!!! 一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少。 可以将楼层划分成多个区间，第一个鸡蛋 E1 用来确定 N 属于哪个区间，第二个鸡蛋 E2 按顺序遍历该区间找到 N。那么问题就转换为怎么划分区间满足最坏情况下扔鸡蛋次数最少。 E1 需要从第一个区间开始遍历到最后一个区间。如果按等大小的方式划分区间，即 E2 的遍历次数固定。那么最坏的情况是 N 在最后一个区间，此时 E1 遍历的次数最多。为了使最坏情况下 E1 和 E2 总共遍历的次数比较少，那么后面的区间大小要比前面的区间更小。具体来说，E1 每多遍历一次，E2 要少遍历一次，才使得 N 无论在哪个区间，总共遍历的次数一样。设第一个区间大小为 X，那么第二个区间的大小为 X-1，以此类推。那么 X + (X-1) + (X-2) + … + 1 = 100，得到 X (X + 1) / 2 = 100 ，即 X = 14。 老鼠喝酒 一共1000瓶酒，其中一瓶有毒。如果一只老鼠喝了有毒的酒，会在一天之后死亡，那么如果给你一天时间，然你判定哪瓶酒有毒，至少需要几只老鼠？ 答案 答案是10只。这个需要使用二进制编码来解决，1000瓶酒至少需要10位二进制数来进行编码。然后取十只杯子分别代表这是个二进制数的十个位，分别将1000瓶酒倒入其编码为1的对应的杯子中。取十个老鼠分别喝十个杯子中的酒，一天之后，就可以根据喝哪些杯子的老鼠死掉来确定出有毒的那瓶酒的编码，从而确定哪瓶酒有毒。其根据就是只有有毒酒的编码对应的毒死老鼠的杯子位置。这个题目就是利用了二进制编码的一些特性。 国王有10000桶酒，已知一桶酒有毒，喝了之后一定会在23-24小时内死亡（例如0点喝，会在23-第二天0点这个时间段死亡）。现在国王要在48小时后举办一个宴会，需要用罪犯实验，请问最少几个罪犯。（可以混合酒） 如果是常规利用二进制解题的话，那就需要14个犯人，2^14=16384>10000，但是这样一来死亡时间这个条件就用不到，也不是最优解。 应该利用酒死的时间是固定的，一个罪犯像上面那样可以表示成25种状态，三个罪犯就可以表示25 x 25 x25种状态，超过10000了，所以只需要三个罪犯。 拓展 还有一些其他的题目也使用这些特性，比如使用特殊的位运算，一般使用比较多的位运算就是与、或和异或。 这样，就可以对应到现实生活中的一些为题，比如一个类似的问题原本我们想需要用900多台服务器来解决，经过这样分析后就可以使用10台服务器来解决，大大节约了成本。 计量 用绳子计时 15 分钟 给定两条绳子，每条绳子烧完正好一个小时，并且绳子是不均匀的。问要怎么准确测量 15 分钟。 点燃第一条绳子 R1 两头的同时，点燃第二条绳子 R2 的一头； 当 R1 烧完，正好过去 30 分钟，而 R2 还可以再烧 30 分钟； 点燃 R2 的另一头，15 分钟后，R2 将全部烧完。 得到指定容量的水 有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。 可以理解为用若干个 5 和 3 做减法得到 4。 不能从 3 做减法得到 4，那么只能从 5 做减法得到 4，即最后一个运算应该为 5 - 1 = 4，此时问题转换为得到 1 升的水； 1 升的水可以由 3 做减法得到，3 - 2 = 1，此时问题转换为得到 2 升的水； 5 - 3 = 2。 一个5L，一个6L的瓶子，要得到3L的水，问什么方法 答案 6-5=1 1L水放在5L那个瓶里面，然后再装6L水，往5L（里面已经有1L）里面倒，这样就会剩下2L水在6L里面，再把2L水放在5L里面，再装一次，不就可以6L那里到处3L水到5L里面，自己就剩下3L了 红白帽子推理 一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其它人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？ 答案 三个人 若是两个人，设A、B是黑帽子,第二次关灯就会有人打耳光。原因是A看到B第一次没打耳光，就知道B也一定看到了有带黑帽子的人，可A除了知道B带黑帽子外，其他人都是白帽子，就可推出他自己是带黑帽子的人！同理B也是这么想的，这样第二次熄灯会有两个耳光的声音。 如果是三个人，A,B,C。A第一次没打耳光，因为他看到B,C都是带黑帽子的；而且假设自己带的是白帽子，这样只有BC戴的是黑帽子；按照只有两个人带黑帽子的推论，第二次应该有人打耳光；可第二次却没有...于是他知道B和C一定看到了除BC之外的其他人带了黑帽子，于是他知道BC看到的那个人一定是他，所以第三次有三个人打了自己一个耳光 拓展: N个人是黑帽子，就会在第N天，有N个人打自己一个耳光。 吃药片 一个是两种药片，每种有两个，一个人需要早上吃两种药片各一个，现在这四个药片混在一起了这个人什么方法吃。 答案 把所有的4颗药丸都切开成相等的两半，然后早上和晚上，分别吃掉每颗药丸的一半 操作 飞机加油 本体图解参考：https://blog.csdn.net/hinyunsin/article/details/6632062 已知： 每个飞机只有一个油箱，飞机之间可以相互加油（注意是相互，没有单独的加油机），一箱油可供一架飞机绕地球飞半圈。问题：为使至少一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机？（所有飞机从同一机场起飞，而且必须安全返回机场，不允许中途降落，中间没有飞机场） 答案 分为3架飞机5架次和3架飞机6架次 3架飞机6架次 ABC 3架同时起飞 1/8处，C给AB加满油，C返航。此时飞机的油量分别是：A: 3/4, B: 3/4, C: 3/4。此时C分别给A和B加满油，三架飞机当前油量分别是：A: 1, B: 1, C: 1/4。C返回机场。A、B继续向前飞行。 1/4处，B给A加满油，B返航，A到达1/2处，此时C已经返回机场，三家飞机此时油量分别是：A: 3/4, B: 3/4, C: 0。此时B给A加满油，C加满油，此时三架飞机的油量分别是：A: 1, B: 1/2, C: 1。然后B返回机场，A继续向前飞行。 当A飞行至半圈位置时，B已经返回机场并且加满了油（假设加油时间为0），此时，B和C沿逆时针方向飞行，三架飞机当前油量分别是：A: 1/2, B: 1, C: 1。A继续向前飞行。 当A飞行至另外半圈的1/4位置时，三架飞机剩余油量分别是：A: 1/4, B: 3/4, C: 3/4。此时，C给B加满油。此时三架飞机油量分别是：A: 1/4, B: 1, C: 1/2。C返回机场，B和A继续向前飞行。 当A飞行至另外半圈的1/2位置时，C已经返回机场，A和B相遇，此时三架飞机剩余油量分别是：A: 0, B: 3/4, C: 0。B给A加1/4的油，三架飞机剩余油量：A: 1/4, B: 1/2, C: 1。C加满油从机场逆时针飞出，B返回机场，A继续向前飞行。 当A飞行至另外半圈的3/4位置时，A和C相遇。此时三架飞机的油量分别是：A: 0, B: 1/4, C: 3/4。C给A加1/4的油，此时三架飞机的油量分别是：A: 1/4, B: 1/4, C: 1/2。C掉头返回机场，A和B继续向前飞行。 三架飞机顺利回到机场！ 3飞机5架次 （1）3 架飞机同时从机场出发，飞行八分之一周（A点），各耗油四分之一。此时某架飞机给其余两架补满油，自己返回基地； （2）另一架飞机和目标机结伴，飞至四分之一周（B点），给目标机补满油，自己返回； （3）目标机独自飞行半周（C点）； （4）与从基地反向出发的一架飞机相遇，2 机将油平分，飞至最后八分之一处（D点）； （5）与从基地反向出发的另一机相遇，各分四分之一油，返回。 移动玻璃杯 周雯的妈妈是豫林水泥厂的化验员。 一天，周雯来到化验室做作业。做完后想出去玩。 \"等等，妈妈还要考你一个题目，\"她接着说，\"你看这6只做化验用的玻璃杯，前面3只盛满了水，后面3只是空的。你能只移动1只玻璃杯，就便盛满水的杯子和空杯子间隔起来 吗?\" 爱动脑筋的周雯，是学校里有名的\"小机灵\"，她只想了一会儿就做到了。请你想想看，\"小机灵\"是怎样做的? 把第二个满着的杯子里的水倒到第五个空着的杯子里 枪战 todo!!! 三个小伙子同时爱上了一个姑娘，为了决定他们谁能娶这个姑娘，他们决定用手枪进行一次决斗。小李的命中率是30％，小黄比他好些，命中率是50％，最出色的枪手是小林，他从不失误，命中率是100％。由于这个显而易见的事实，为公平起见，他们决定按这样的顺序：小李先开枪，小黄第二，小林最后。然后这样循环，直到他们只剩下一个人。那么这三个人中谁活下来的机会最大呢？他们都应该采取什么样的策略？ 小黄。 因为小李是第一个出手的，他要解决的第一个人就会是小林，这样就会保证自己的安全，因为如果小黄被解决，自己理所当然地会成为小林的目标，他也必定会被打死。而小黄如果第一枪不打小林而去打小李，自己肯定会死（他命中较高，会成为接下来的神枪手小林的目标）。他必定去尝试先打死小林。那么30% 50%的几率是80%（第一回合小林的死亡率，但会有一点点偏差，毕竟相加了）。那么第一回合小黄的死亡率是20%多一点点（小林的命中减去自己的死亡率）。假设小林第一回合死了，就轮到小李打小黄了，那么小李的命中就变成了50%多一点点(自己的命中加上小黄的死亡率）。这样就变成了小李小黄对决， 第二回合的小李的第一枪命中是50%，小黄也是。可是如果拖下去的话占上风的自然就是小黄了，可能赢得也自然是小黄了。至于策略我看大家都领悟了吧。 硬币覆盖 todo!!! 在一张长方形的桌面上放了n个一样大小的圆形硬币。这些硬币中可能有一些不完全在桌面内，也可能有一些彼此重叠；当再多放一个硬币而它的圆心在桌面内时，新放的硬币便必定与原先某些硬币重叠。请证明整个桌面可以用4n个硬币完全覆盖 假如先前N个中没有重叠且边上的都超出桌子的边上且全都是紧靠着的.那么根据题意就可以有: 空隙个数Y=3N/2+3(自己推算), 每一个空都要一个圆来盖, 桌面就一共有圆的数为: Y = N+3N/2+3 = 5N/2+3 所以可以用4N个硬币完全覆盖. 参考： 面试智力题集锦 75道程序员面试逻辑题和答案 精选程序员面试常问的逻辑题 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-21 13:02:03 "},"cs/Project/project.html":{"url":"cs/Project/project.html","title":"项目","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-15 07:50:44 "},"cs/Project/flowCtrol.html":{"url":"cs/Project/flowCtrol.html","title":"流量控制","keywords":"","body":"简介 流量控制是在通信系统中系统过载或网络拥塞时，主动减少接纳或发出的业务量，防止系统崩溃并将实际接纳业务量逼近网络处理能力的一种故障自动恢复机制。 流控的方法包括拥塞控制和过载控制两种。拥塞控制主要是配置系统每秒最大的数据报文的处理数量，当超过这个界限的时候就丢弃数据。一般是对于通信业务流程的首消息进行的，数据报的的数量对应着用户数。这个值是通过经验值来设定的，代表设备最大的接入量。 过载控制主要是根据CPU的使用量，CPU用量超过80%且持续5秒，就判断系统过载，然后根据控制理论的PID原理为不同优先级的消息分配令牌，没有获得令牌的消息就会被流控掉。 遇到的挑战 这个任务的时间比较紧，除了流控功能之外，还有许多辅助的配置命令，流控告警功能需要开发。解决方法：将问题分解，逐个开发，分批次合入代码，保证功能持续可用与功能增强。 流控功能的验证，因为一般的测试环境构造不了大话务的场景，所以需要想办法，在网上搜索人为提高CPU使用率的方法。达到流控门限，然后测试流控的功能。 验证的时候发现了已经流控掉，但是CPU和内存都冲高导致微服务挂掉，一开始不知道是哪有问题，后开看了error日志，发现一致循环打某个调用栈，内存耗尽导致。那个地方是封装的一个error接口，error里面又有error，导致存在无穷递归调用。 亮点 在着手之前，对流控功能需求和实现原理了解了一下，并且设计了全套的业务流控，包括流控的功能实现、参数配置功能、告警功能、消息数目数据统计功能等一系列的看护手段。保证了功能的健壮性。 【复盘改进】 由于时间太赶，在前期设计细节研究不够，导致部分理解偏差，实现不人性化。比如上报系统过载的告警，应该是在系统从非流控状态切换到流控状态的时候，发出一条消息，告诉周边模块本模块过载了。但是，我原始实现的是每当有一条消息被流控掉，就上报告警，这样会导致系统严重过载时界面上出现很多告警。其实就和设计衣服或者房子一样，在动手前，最好做出一个高保真的模型，避免返工。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-16 23:41:51 "},"career/guidance/guidance.html":{"url":"career/guidance/guidance.html","title":"Guidance","keywords":"","body":" 我的12年等于24年-李明博 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-20 22:28:32 "},"career/guidance/limingbo.html":{"url":"career/guidance/limingbo.html","title":"我的12年等于24年","keywords":"","body":"我的12年等于24年 李明博 李明博，1941年生于日本大阪，4岁随家人返回韩国。大学毕业后加入韩国现代集团，1977年，36岁的他成为现代集团的CEO。2002年当选为首尔市市长。他以当CEO的理念从政，政绩显著。2007年12月19日当选韩国新一任总统。 文章来源：http://www.360doc.com/content/10/0426/21/1241685_25033594.shtml 你尽全力了吗 —些人对我能够在20岁当理事、30岁当社长、40岁当会长不理解而提问时，话题经常是“快速提升”的秘诀是什么?回答这类问题，我感到十分困惑。因为我从来没有想过有什么秘诀，我的职位和职责有利于我做事，没有别的理由。而且每次升职都是企业主的决定，我无法左右。 我虽然进入公司只有12年就被提升为社长，但我这12年与普通人的12年不同。我从没有过公休日，并且每天工作18个小时以上，相当于别人的两倍。这么计算的话，我等于是24年后才提任社长的，所以也不能说“过快”。 大部分人从企业主或上级接到某项工作任务时，一般都会首先列出面临的困难，并说明目前的人力、资金、技术、信息有多么恶劣，预先为失败找好各种借口。如果事情成功了，会大声炫耀，若失败了就会说：“你看，当初我说什么了?”但是，我提出的目标始终超过企业主的目标，并为实现该目标竭尽了全力。每次我送到郑会长面前的方案总是比郑会长的期望值高出一截。如果郑会长向我提出“最好不要再出现赤字了”，我不仅会不让赤字出现，而且会提出可以赢利的新目标，并加以实现。企业的利润完全属于企业主，我得到的是成就感，我完全是为了这个成就感而工作。 如果怕达不到目标，或想要炫耀自己而故意制定低目标的行为，就是自己放弃自己的主人权利。主人注重的目标不是数值，而是利润，并且不关心别的事情，只关心与工作本身有关的问题。 不要与同事竞争，应该把企业主作为自己的竞争对象，像企业主一样去思考，像企业主一样查找问题，一同去解决它，并且还要制定出比企业主要求更高的目标。郑会长每次遇到危机就找我的理由是：“李明博像我一样，不，他比我更把公司当成自己的。”这种印象经常出现在他的脑海里。 　　 因为是职业所需，所以凌晨两点也要用工作状态接听电话。从海外打过来的电话我都亲自接，深夜也好，凌晨一两点也好。亲自接国际电话是有原因的，如果按韩国总部习惯打电话的话，在海外只好等到深更半夜或凌晨，这样会延误问题的处理。如果错过总部日常业务时间不接电话，就要浪费现场和总部双方两天的时间。在今天面对瞬息万变的世界，两天的时间是多么宝贵啊! 每次接电话我都非常注意，从海外给社长打电话时，肯定知道韩国这边的时间，如果是凌晨2点，我用充满睡意的声音很不耐烦地接电话，哪个分公司员工敢再来电话呢? 他们心里会想：“还什么时候都可以打电话呢，听这接电话的声音……还不如不说。” 经过反复练习，我可以做到任何时候接电话都像正常工作那样声音洪亮、清晰，同时做记录。在海外分公司工作的职工从电话里得出这样一个结论： “我们社长晚上也不睡觉。”那时我已经练就了在沉睡中听到电话铃声，马上可以用清醒的声音接电话，之后再重新入睡的本事。 由于从小养成早起的习惯，上中学到现在，我从未睡过5个小时以上的觉，起床的时间固定在5点。在韩国是这样，到世界任何地方都是这样，都是于当地时间5点准时起床。这可是训练出来的。我从不在飞机上睡觉，如果睡着了就无法适应目的地的时间。在飞机上我一般读书，下了飞机我直奔网球场(工作现场一般都有网球场)。打网球打出一身汗再去睡觉，当地时间5点准能起床。不管晚上几点睡，早上5点准时起床，在国外见过我的人，对此都很惊讶。我想，去海外并不是去玩，是为了帮助在当地辛勤工作的职员，怎么可以睡懒觉呢。别人以为我早起是先天的，事实并非这样，靠的是努力，除了反复的努力之外没有什么别的秘诀。 　　 没有一个地方能贴出这样的招聘广告：“这里给你准备了与你的性格完全相符的工作，请到这里来吧!” 改变自己适应工作 秉性要适应工作这是我对刚进公司的大学生职员经常说的话。“各位以前都是学生，从现在开始，从一个评判别人的人变成了接受评判的对象。仅一年之差，却已成为事实。单靠大学时代的世界观是无法在社会上取得成功的，甚至无法适应这个社会，但如果用积极的思考方式，就能发挥出巨大的能量。” 许多事情是在行与不行的想法之间徘徊的。认为不行的人脑海里只充满了不行的可能性和理由，而认为行的人，即使只存在1％的可能性，也会抓住这个希望不放的。即使没有这1％的可能性，哪怕是100％要失败的事儿，面对它的人也会从中获得经验。没有努力过的人什么也留不下，我用50比0的比率来计算这种差异，对任何事都要以积极的挑战意识去对待的理由就在于此。 我向新职员还说了这么一段话： “要改变自己的性格。不要首先判断这份工作是不是适合我，而是要改变性格去适应工作。”也许有人会反驳我说，这是要让身体去适应床，是带有权威色彩和非科学的思维方式，但我的方法比较实用。拿我来说，其实不会再有第二个像我这样不适合建筑业的人了。 我的成长时期，经历了非常艰苦的生活，在与贫穷斗争中，我的性格比任何人都内向、害羞，但我通过努力改变了性格。出任学生会长，领导学生运动，并且投身建筑业，使性格变得外向、开朗起来。性格并不是固定不变的。 这个世界不会只把适合你的工作交给你，尤其是在企业内部，刚步人社会的年轻职员要找到非常适合自己性格的工作谈何容易。如果只想找适合自己性格的工作，什么工作也做不了。 不要自我限定想做的工作和可以做的工作，把自己的性格调整到要做的工作上去，这是非常有效的方法。因为世界上没有一个地方能贴出这样的招聘广告：“这里给你准备了与你的性格完全相符的工作，请到这里来吧!” 为能动的自己做主人 在公司里要逐渐去掉新职员的稚气，尽快熟悉业务，否则，就会跟你的顶头上司发生冲突。如果能遇上志同道合的上司，那你就是世界上最幸福的职员。但这种概率比找到适合自己性格的工作更难。 上班族的压力不是工作本身，而是来自因工作而发生摩擦的人。假如一个工长遇上了一位合不来的科长，那么这位工长就无法得到上司对他的认可。如果一个职员无法得到顶头上司的认可，那他就成不了最后的胜者。希望遇上一个总是肯定自己、引导自己的上司，这种想法简直是不现实的，甚至是愚蠢的。因为世界上与你合不来的上司远远多于让你如意的上司。跟现在的上司不合，觉得“这个样子没法再干下去了……”就提出辞职，再去别的公司，你能保证那里就没有“这个样子”的上司吗? 性格不适应就要改变性格，这句话在任何时候都适用。如果遇上性格不合的上司，就要改变你自己的性格。再说，也不可能始终与如意的上司共事，或许会遇上比现在更糟糕的上司，那也说不定。如果具备改变性格的能力，就可以与任何上司共事。希望并等待更换对方，或想说服对方，是达不到好的预期效果的。将对方看成固定不变的物体，这时能动的就只有我了，结果是我做主人。 具有改变自己性格的能力的人，他可以克服任何阻碍。只要逃避过一次，那他就会总是想着如何逃避。把握工作,把握时间我做事儿从不后悔。 假如我能重新出生，并重新做我做过的事儿，能不能做得更好?很多人会说，只要再有一次机会就会更加努力，会取得更好的成果。但我不同，如果重新再做，肯定不会做得更好。所以工作方面没有什么可后悔的。 我如此努力工作是为了什么呢? 抱怨贫穷的父母，只能换来没有意义的一生。我从来不抱怨父母，也从来没有抱怨过这个贫穷的国家。让我生在这片土地上是为了让我努力工作，我这样想，如果跟跑在我们前面的人一样睡觉、一样做事，就无法赶上他们。 只有比他们更努力工作，才能享受到跟他们同样的生活。如果以工作为由，不做或做不了其他重要事情，那就是工作狂。因为工作忙而把生活中重要的事情，例如，供养父母、照顾家庭、与朋友交流等丢在脑后，那就失去了忙的价值和意义。把握工作就等于把握时间。某人5个小时能完成的工作，别人用10个小时才能完成，那这后面的人，即使把握了工作，却未能把握时间。因此，从结果来看，等于输给了工作。 　　 周末也要穿西装上班 　　 观察一下周末上班的职员，一般都穿着休闲服，是为了下班后直接去玩。我觉得这是个错误的想法。穿着休闲服，一天总在想下班后去玩儿的事情，就无法做好工作。所以我对周末穿西装要求很严。如果下班后去玩儿的话，备好衣服，工作结束了再换上。如果做不到这一点,周末干脆别上班了。 美国和日本的汽车产业是个对比。美国汽车工厂周五生产的产品次品最多，因为工人都沉浸在周末的气氛里； 日本汽车工厂从周一到周末生产的产品质量相同，因为日本严格区分工作与休息。 曾去过德国一家设计公司，办公室里没有椅子，所有的人都站着工作。除了上下午各有30分钟休息时间外，一直都要站着，对他们来说休息时间就是黄金时间。这与流着汗爬到山顶后，感觉到的那种分外的舒畅和愉快是一样的道理。 对不努力工作的人来说，休息、休息日、休假并不能成为黄金时间。 理清公私关系很重要，区分工作与休息也很必要。工作的时候，不要让其他想法和杂念干扰你，要专注于工作，那样才能珍惜和享受休息时间。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-20 18:57:41 "},"Self/read/read.html":{"url":"Self/read/read.html","title":"Reading","keywords":"","body":"摘抄 愤怒和敌对的确可能引发暴躁和混乱，但同时也可以驱动我们反抗压迫，坚持真理，在未知险途上坚定前行。 ——乔丹*彼得森《人生十二法则》 凡事豫则立，不豫则废。言前定，则不跲；事前定，则不困；行前定，则不疚；道前定，则不穷。 凡事提前有准备则会成功，否则会失败。说话提前准备就不会理屈词穷；行事前现有定夺就不会有困难阻碍；一个行为提前准备了就不会后悔；路提前考虑好就不会走投无路。 豫：通“预”；跲[jiá]：绊倒，受阻碍，这里指理屈词穷；困：困难，阻碍；疚：后悔；穷：走投无路。 ——《礼记·中庸》 心灵鸡汤 找到一样你所钟爱的事物，然后，永不放手。Find the thing you love and stick with it. 活在别人的眼光下，不如活在自己的期待中。 最短的距离是从手到嘴，最长的距离是从说到做。 惧怕将来，留恋过去，唯独忘了活在当下。 相信事在人为，也相信尽力无悔。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-23 10:27:39 "},"Self/read/booklist.html":{"url":"Self/read/booklist.html","title":"书单","keywords":"","body":"CS 用户体验 《设计师要懂心理学》【美】Susan Welnschenk 人民邮电出版社 架构 《企业IT架构转型之道-阿里巴巴中台战略思想与架构实战》 程序员素养 《程序员的思维修炼-开发认知潜能的九堂课》 《高效程序员的45个习惯-敏捷开发修炼之道》 《程序员修炼之道-从小工到专家》 《软件工艺》人民邮电出版社 《卓有成效的程序员》 《程序员的职业素养》 《高效能程序员的修炼》 《THE EFFECTIVE ENGINEER》 思想 《思考，快与慢》 《断舍离》 《MINDSET》中文版《终身成长》 《看见成长的自己》 《驱动力》丹-平克 思想哲学 《单向度的人-发达工业社会意识形态研究》马尔塞库 《理想国》柏拉图 《乌托邦》托马斯·莫尔 《太阳城》康帕内拉 《历史的起源与目标》雅斯贝尔斯 《政府论》洛克 《论法的精神》孟德斯鸠 《社会契约论》卢梭 《法哲学原理》黑格尔 《联邦党人文集》汉密尔顿 文学 现当代文学 《鲁迅全集》 《创业史》柳青 《老舍全集》 《取经》贾大山 外国名著 《浮士德》 《仲夏夜之梦》莎士比亚 《威尼斯商人》莎士比亚 《第十二夜》莎士比亚 《罗密欧与朱丽叶》莎士比亚 《哈姆雷特》莎士比亚 《奥赛罗》莎士比亚 《李尔王》莎士比亚 《麦克白》莎士比亚 《老人与海》海明威 《怎么办？》车尔尼雪夫斯基 《野性的呼唤》杰克·伦敦 《海狼》杰克·伦敦 《当代英雄》莱蒙托夫 《包法利夫人》福楼拜 《静静的顿河》肖洛霍夫 《战争与和平》托尔斯泰 《红与黑》司汤达 《神曲》但丁 《十日谈》蒋伽丘 《巨人传》拉伯雷 《九三年》雨果 《悲惨世界》雨果 经史典籍 《史记》 《春秋》 《诗经》 《礼记》 《管子》 《古诗源》 《唐宋八大家散文鉴赏大全集》 《宋词选》 《智囊》 《中国古典文心》 《红楼梦》 《文心雕龙》 政治学 《共产党宣言》马克思，恩格斯 《资本论》马克思 《政治学》亚里士多德 《中国环球宏观战略研究》 《世界秩序》 经济学 《国富论》 《人口原理》马尔萨斯 《就业利息和货币通论》凯恩斯 《经济发展理论》约瑟夫·熊彼特 《经济学》萨缪尔森 《资本主义与自由》弗里德曼 《各国的经济增长》西蒙·库兹涅茨 《21世纪资本论》托马斯·皮凯蒂 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-02 20:02:20 "},"Self/read/poetry.html":{"url":"Self/read/poetry.html","title":"诗词","keywords":"","body":"志向篇 登科后 孟郊 昔日龌龊不足夸，今朝放荡思无涯。 春风得意马蹄疾，一日看尽长安花。 龌龊：此处指不如意。 放荡：自由自在，无拘无束。 思无涯：兴致高涨。 疾：快。 行路难（其一） 李白 金樽清酒斗十千，玉盘珍羞直万钱。 停杯投箸不能食，拔剑四顾心茫然。 欲渡黄河冰塞川，将登太行雪满山。 闲来垂钓碧溪上，忽复乘舟梦日边。 行路难！行路难！多歧路，今安在？ 长风破浪会有时，直挂云帆济沧海。 闲来垂钓二句：暗用典故姜太公钓鱼和伊尹梦见自己乘船从日月旁经过，姜公助周文王灭商，伊尹助商汤灭夏。表示对从政尚有期待。 长风破浪：南朝宋名将宗悫què少年时志向“愿乘长风破万里浪”。 柔情篇 钗头凤·红酥手 陆游 红酥手，黄縢酒，满城春色宫墙柳。东风恶，欢情薄。一怀愁绪，几年离索。错错错。 春如旧，人空瘦。泪痕红浥鲛绡瘦。桃花落，闲池阁。山盟虽在，锦书难托。莫莫莫。 红润酥腻的手里，捧着盛上黄縢酒的杯子。满城荡漾着春天的景色，你却早已像宫墙中的绿柳那般遥不可及。春风多么可恶，欢情被吹得那样稀薄。满杯酒像是一杯忧愁的情绪，离别几年来的生活十分萧索。错，错，错！（错误，错落，错责） 美丽的春景依然如旧，只是人却白白相思地消瘦。泪水洗尽脸上的胭脂红，又把薄绸的手帕全都湿透。满春的桃花凋落在寂静空旷的池塘楼阁上。永远相爱的誓言还在，可是锦文书信再也难以交付。莫，莫，莫！（罢了） 钗头凤·世情薄 唐婉 世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残，欲笺心事，独语斜阑。难难难。 人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊，怕人询问，咽泪装欢。瞒瞒瞒。 阑珊：将尽。 青玉案·凌波不过横塘路 贺铸 凌波不过横塘路，但目送，芳尘去。锦瑟华年谁与度？月桥花院，琐窗朱户，只有春知处。 碧云冉冉蘅皋暮，彩笔新题断肠句。试问闲愁都几许？一川烟草，满城风絮，梅子黄时雨。 风景篇 小池 杨万里 泉眼无声惜细流，树阴照水爱晴柔。 小荷才露尖尖角，早有蜻蜓立上头。 惜：吝惜。 晴柔：晴天里柔和的风光。 泉眼悄然无声是因为舍不得细细的水流，树阴倒映在水面上是喜爱晴天里柔和的风光（树阴似乎在用树荫盖住小池，以免水分蒸发）。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-18 23:34:58 "}}