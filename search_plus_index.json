{"./":{"url":"./","title":"Introduction","keywords":"","body":"Welcome To Moresuccessful Zone! 做一个快乐而丰富多彩的螺丝钉！ Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-16 23:46:04 "},"ComputerNetworks/computerNetworks.html":{"url":"ComputerNetworks/computerNetworks.html","title":"计算机网络","keywords":"","body":"计算机网络 应用层 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-04 23:57:14 "},"ComputerNetworks/applicationLayer.html":{"url":"ComputerNetworks/applicationLayer.html","title":"应用层","keywords":"","body":"http http请求 cookie与session 请求方法与幂等性 cookie v.s. session cookie存储在浏览器上，最大存储量为4KB。session存储在服务器端，大小无限制。 cookie可以轻松访问，但是session不能，因此session更安全。 设置cookie时间可使cookie过期，而删除回话需要执行session destroy操作。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 00:06:27 "},"ComputerNetworks/transportLayer.html":{"url":"ComputerNetworks/transportLayer.html","title":"传输层","keywords":"","body":"三次握手 四次挥手 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:38:32 "},"OperatingSystem/operatingSystem.html":{"url":"OperatingSystem/operatingSystem.html","title":"操作系统","keywords":"","body":"操作系统 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 11:00:37 "},"OperatingSystem/processAndThread.html":{"url":"OperatingSystem/processAndThread.html","title":"X程","keywords":"","body":"进程与线程 进程 线程 定义 进程是指程序在数据集上的一次运行，是系统资源分配和调度的基本单元； 线程是进程的一个实体，是CPU调度的基本单元 资源分配与CPU调度 1. 进程之间不共享资源2. 在没有线程的操作系统中，进程既是资源分配的基本单位，又是调度的基本单位3. 一个进程至少有一个线程，即主线程，也可以有多个线程协同工作 1. 线程并不拥有资源，只是使用他们，进程是资源分配和拥有的基本单元。2. 在有线程的操作系统中，进程是资源分配的基本单位，线程是调度的基本单元3. 线程是指进程内的一条执行线路，或者说是进程中可执行代码的单独单元，它是操作系统的基本调度单元。4. 动态性：线程也是程序在相应数据集上的一次执行，由创建而产生，至撤销而消亡，有其生命周期 组成 进程是PCB（进程管理块）结构与程序和数据的组合 通讯 由于同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核 进程 进程间通信 1）消息队列（Message） 消息队列是消息的链接表。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 2）共享内存 使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 3）管道（Pipe）及有名管道（named pipe） 管道可用于具有亲缘关系进程间的通信（父子进程），有名管道克服了管道没有名字的限制，它还允许无亲缘关系进程间的通信； 4）信号（Signal） 信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身； 5）信号量（semaphore） 资源计数器。主要作为进程间以及同一进程不同线程之间的同步手段。 6）套接口（Socket） 更为一般的进程间通信机制，可用于不同机器之间的进程间通信。 线程 线程安全 LINK 管程 协程 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-19 13:33:43 "},"Golang/Golang.html":{"url":"Golang/Golang.html","title":"Golang","keywords":"","body":"Golang slice 携程 channel 底层实现 pprof go marshal 代码依赖 vendor gradlew Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-11 23:13:52 "},"DataStructAndAlgorithm/dataStructAndAlgorithm.html":{"url":"DataStructAndAlgorithm/dataStructAndAlgorithm.html","title":"数据结构与算法","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 10:55:51 "},"DataStructAndAlgorithm/leetcode.html":{"url":"DataStructAndAlgorithm/leetcode.html","title":"Leetcode","keywords":"","body":"目录 42. 缺失的第一个正数 46. 全排列 96. 不同的二叉搜索树 153. 寻找旋转排序数组中的最小值 200. 岛屿数量 403. 青蛙过河 698. 划分为k个相等的子集 779. 第K个语法符号 794. 有效的井字游戏 894. 所有可能的满二叉树 912. 排序数组 923. 三数之和的多种可能 993. 二叉树的堂兄弟节点 1277. 统计全为 1 的正方形子矩阵 1278. 分割回文串 III 42. 缺失的第一个正数 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 与剑指 offer第三题类似，不同之处在于可能出现负数或大于数组长度n的数。对于这样的数跳过即可，对其他1～n的数换到下标0～n-1的位置。如果数组内数据为[1,2,...,n], 那么第一个未出现的正数是n+1，所以第一个未出现的正数范围是1～n+1。 nums[i] == i+1 符合置换条件，不需要交换。 nums[i] == nums[nums[i]-1] 两个交换值相等的情况下，会产生死循环，所以也无需交换，继续下一个。 func firstMissingPositive(nums []int) int { n := len(nums) for i := 0; i n || nums[i] == i+1 || nums[i] == nums[nums[i]-1]){ i++ } if i46. 全排列 给定一个没有重复数字的序列，返回其所有可能的全排列。 TAG：【递归】【回溯】 假设数字序列为[0...n-1],首先是确定第一个数，将序号为0～n-1的数分别与第一个数交换位置。交换完了之后要恢复数组原貌，再确定第二个数，将第二个数后面所有数字和第二个数交换。如此，直到确定了所有数之后就得到了一个结果。 注意这里储存结果的二维数组必须得使用指针，否则结果传不出来。 如果不恢复原貌，得到的结果会有重复，并且得到的结果不全。 交换一定要从start开始，而不是start+1， func permute(nums []int) [][]int { var results [][]int backTrace(nums, &results,0) return results } func backTrace(nums []int, results *[][]int, start int){ if start == len(nums){ *results = append(*results,append([]int{},nums...)) } for i := start; i 96. 不同的二叉搜索树 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ TAG：【动态规划】 本题是一维的动态规划算法，构造result[i]代表1～i组成的二叉搜索树的种类。可以知道m~n的二叉搜索树的种类等于1～n-m+1为节点组成的二叉搜索树。又根据二叉搜索树的性质，root左边的数小于root，右边的数大于root。因此，1～i为节点的二叉搜索树的种类是以1～i分别为root时左右两边二叉树种类的乘积。 func numTrees(n int) int { var result = make([]int, n+1) result[0] = 1 result[1] = 1 for i:=2;i153. 寻找旋转排序数组中的最小值 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。你可以假设数组中不存在重复元素。 旋转数组前半部分所有数字值大于后半部分，需要找到旋转点。所以判断一截数组，如果第一个元素大于最后一个元素，说明这截数组仍然是旋转数组。 要判断end-start==1的情况，应为当这种情况下，mid=(start+end)/2会出现mid==start，从而造成死循环。 本题假设没有重复数字，当有重复数字时，会有nums[start] == nums[end]==nums[mid]的情况，这个时候需要顺序查找最小值。 func findMin(nums []int) int { if len(nums) == 0 { return 0 } start, end :=0, len(nums)-1 for nums[start] > nums[end]{ if end -start == 1{ return nums[end] } mid := (start + end)/2 if nums[start] >= nums[mid] { end = mid } else if nums[start] 200. 岛屿数量 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 TAG:【图】【递归】【深度优先】【广度优先】 深度优先搜索：关键词递归 从某个点开始，如果值是1，说明至少有1个岛，岛屿的数量+1. 然后从这个点开始深度优先深度从上下左右四个方向开始深度优先搜索，直到遍历到值是0的点，将之前遍历到的值是1的点改成0. 知道所有点被遍历完为止。 广度优先搜索：关键词队列 与深度优先搜索一样，不同点在于，把当前节点周围值为1的节点都存储下来，依次遍历直到邻接点是0为止。 // 深度优先搜索 func numIslands(grid [][]byte) int { result := 0 for i := 0; i = 0 && (*grid)[x-1][y] == '1' { (*grid)[x-1][y] = '0' dfs(grid, x-1, y) } if x+1 = 0 && (*grid)[x][y-1] == '1' { (*grid)[x][y-1] = '0' dfs(grid, x, y-1) } if y+1 // 广度优先算法 func numIslands(grid [][]byte) int { if len(grid) == 0{ return 0 } result := 0 neigbor := make([]int, 0) row := len(grid) col:=len(grid[0]) for i := 0; i 0{ x,y:=neigbor[0]/col,neigbor[0]%col neigbor = neigbor[1:] if x-1 >= 0 && grid[x-1][y] == '1' { grid[x-1][y] = '0' neigbor = append(neigbor, (x-1)*col+y) } if x+1 = 0 && grid[x][y-1] == '1' { grid[x][y-1] = '0' neigbor = append(neigbor, x*col+y-1) } if y+1 403. 青蛙过河 给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。实例：输入[0,1,3,5,6,8,12,17]，输出true。 TAG：【动态规划】 本题涉及二维的动态规划 dp[i][j] 表示在stones[i]上可以跳跃j步。 当计算到dp[i][j]， i=n-1且存在为true的j时，说明前一个节点也可以跳j步到达这最后一个石头上。 func canCross(stones []int) bool { var dp = make([][]bool, len(stones)) // 在stones[i]上可以跳跃j步 for i := range dp { dp[i] = make([]bool, len(stones)) } dp[0][1] = true for i := 1; i = len(stones) || !dp[j][dis] {continue}// dis的范围判断是为了dp[j][dis]下标不越界 if i == len(stones)-1 {return true} // 成功判定 dp[i][dis] = true // 更新dp数组 if dis-1 > 0 { dp[i][dis-1] = true} if dis+1 698. 划分为k个相等的子集 给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 TAG：【数组】【递归】【动态规划】 func canPartitionKSubsets(nums []int, k int) bool { total := 0 for i := range nums { total += nums[i] } if k = 0; i-- { if nums[i] > sum { return false } if nums[i] == sum { lastIdx-- k-- } if nums[i] 779. 第K个语法符号 在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始） TAG：【数组】【递归】 按照递归2步走：终止条件，递归式。 func kthGrammar(N int, K int) int { if N794. 有效的井字游戏 用字符串数组作为井字游戏的游戏板 board。当且仅当在井字游戏过程中，玩家有可能将字符放置成游戏板所显示的状态时，才返回 true。该游戏板是一个 3 x 3 数组，由字符 \" \"，\"X\" 和 \"O\" 组成。字符 \" \" 代表一个空位。 以下是井字游戏的规则： 玩家轮流将字符放入空位（\" \"）中。 第一个玩家总是放字符 “X”，且第二个玩家总是放字符 “O”。 “X” 和 “O” 只允许放置在空位中，不允许对已放有字符的位置进行填充。 当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。 当所有位置非空时，也算为游戏结束。 如果游戏结束，玩家不允许再放置字符。 TAG：【数组】【二维】 本题就是找规律，分为以下3个特殊情形： X棋子先下，因此X的数量比O多1个，或者与O相等，其他情况说明不符合游戏规则，返回false。 当X满足赢的条件的时候，X数量比O多1，否则返回false。 当O满足赢的条件的时候，O数量和X一样多，否则返回false。 func validTicTacToe(board []string) bool { cntO,cntX:=count(board) if cntX-cntO!= 1 && cntX-cntO!=0{ // 条件1判断 return false } if win(board,'X') && cntX-cntO!=1{ // 条件2判断 return false } if win(board,'O') && cntX!=cntO{ // 条件3判断 return false } return true } func count(board []string)(int,int){ // 获取X和O棋子的个数 var cntO, cntX int for j := 0; j 894. 所有可能的满二叉树 满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。答案中每个树的每个结点都必须有 node.val=0。你可以按任何顺序返回树的最终列表。 TAG：【递归】【树】 递归的思路，N个节点时，根节点占用一个节点，左右子孩子占有N-1个节点，由于是满二叉树，因此如果存在左孩子，必定需要有右孩子，反之亦然。遍历左孩子占用节点树为1～N-2的情况，得出左孩子可能的根节点的数据，将这些根节点接上原始root，则得到了不同的目标答案。 核心在于构建递归函数的入参和出参。理论上，递归函数是可以不设置任何出参的，可以在入参中存储结果。（需要存储结果的原因在于存储下子问题的解，避免重复子问题计算）。由于目标结果是树的头节点的切片[]*TreeNode，因此如果我们需要存在子问题的解，则需要存节点数为1～N范围的结果值，因此，存储结果的类型设置为[][]*TreeNode. func allPossibleFBT(N int) []*TreeNode { if N == 0 { return nil } store := make([][]*TreeNode, N+1) findTree(N, &store) return store[N] } func findTree(N int, store *[][]*TreeNode) { if N == 1 { (*store)[N] = []*TreeNode{&TreeNode{0, nil, nil}} return } result := make([]*TreeNode, 0) for i := 1; i 912. 排序数组 给定一个整数数组 nums，将该数组升序排列。 TAG：【排序】【数组】 快速排序: func quickSort(nums []int){ partition(nums, 0, len(nums)-1) } func partition(nums []int, start, end int){ if start >= end{ return } var i, j = start, end pivot:=nums[start] for i =pivot{ nums[j] = nums[i] j-- break } } } nums[i] = pivot // 置位 partition(nums, start, i-1) // 分治 partition(nums, i+1, end) } 堆排序： func heapSort(nums []int){ for i:=len(nums)/2-1;i>=0;i--{ // 从最后一个非叶子结点开始调整，构造一个完成最大堆 heaplify(nums, i, len(nums)-1) } for j:=len(nums)-1;j>=1;j--{// 将堆定最大元素取出，将堆最后一个叶子结点放在堆定，再调整 nums[0],nums[j] = nums[j],nums[0] heaplify(nums,0,j-1) } } func heaplify(nums []int, start, end int){// 堆的调整 for i := start; inums[i] && (right > end || nums[right]nums[i]{ nums[right],nums[i] = nums[i],nums[right] i=right }else{ break } } } 923. 三数之和的多种可能 给定一个整数数组 A，以及一个整数 target 作为目标值，返回满足 i 【三指针】 由于数字大小范围为0～100，首先采用桶排序，对A数组中的数字出现的次数进行统计，record[i]表示数字i出现的次数，如果没有数字i，则record[i]=0。 定好第一个数，另外两个数分别用首尾指针确定，由于可能出现3个数字中有相同的数的情况，首指针从第一个数的位置开始，首尾指针可以相等。 注意判断特殊情况，第一个数和第二个数相等，第二个数和第三个数相等的情况。 func threeSumMulti(A []int, target int) int { const maxResult = 1000000007 const maxNum = 100 var record = make([]int, maxNum+1) for i := range A { record[A[i]]++ } result := 0 for i := 0; i = j; { if record[j] == 0 || j+k left { k-- continue } if i = 2 { result = (result + ((record[i]*(record[i]-1))/2)*record[k]) % maxResult } else if i = 2 { result = (result + ((record[j]*(record[j]-1))/2)*record[i]) % maxResult } else if record[i] >= 3 { result = (result + ((record[j] * (record[j] - 1) * (record[j] - 2)) / 6)) % maxResult } j++ k-- } } return result } 993. 二叉树的堂兄弟节点 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 TAG：【树】 递归分别求x和y的深度和父节点的值。 func isCousins(root *TreeNode, x int, y int) bool { var xParent, yParent, xdepth, ydepth int xflg:=isChild(root,x,&xParent,&xdepth) yflg:=isChild(root, y,&yParent,&ydepth) if !xflg || !yflg || xParent == yParent || xdepth!=ydepth { return false } return true } func isChild(root *TreeNode, val int, parent *int, depth *int) (bool){ if root == nil { return false} if (root.Left != nil && root.Left.Val== val) || (root.Right != nil && root.Right.Val== val){ *parent = root.Val *depth+=1 return true } if isChild(root.Left, val, parent, depth) || isChild(root.Right, val, parent,depth){ *depth+=1 return true } return false } 1277. 统计全为 1 的正方形子矩阵 给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。 输入：matrix = [ [0,1,1,1], [1,1,1,1], [0,1,1,1] ] 输出：15 解释： 边长为 1 的正方形有 10 个。 边长为 2 的正方形有 4 个。 边长为 3 的正方形有 1 个。 正方形的总数 = 10 + 4 + 1 = 15. 按照边长1～min(row,col)的小正方形的情况，暴力求解。 1278. 分割回文串 III 给你一个由小写字母组成的字符串 s，和一个整数 k。 请你按下面的要求分割字符串： 首先，你可以将 s 中的部分字符修改为其他的小写英文字母。 接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。 请返回以这种方式分割字符串所需修改的最少字符数。 输入：s = \"abc\", k = 2 输出：1 解释：你可以把字符串分割成 \"ab\" 和 \"c\"，并修改 \"ab\" 中的 1 个字符，将它变成回文串。 dp[i][j] = min(dp[i][j],dp[m][j-1]+cost[m+1][i]), m=1...i-1 dp[i][j] 代表字符串s前i个字符分成j个子串需要修改的最少字符数，cost[m][n]代表字符串第m到n个字符的子串变成回文需要修改的最小字符数。（下标均为从1开始） func initCost(s string) [][]int { // cost[i][j]表示第i～j字符段成为回文需要变化的次数，下标0开始 var cost = make([][]int, len(s)) for i := 0; i Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-14 00:46:44 "},"DataStructAndAlgorithm/recursion.html":{"url":"DataStructAndAlgorithm/recursion.html","title":"递归","keywords":"","body":"简介 什么时候用递归？ 可以找到子问题的退出条件。 一个问题可以分解为子问题。 递归的缺点？ 递归的本质是函数调用自身。函数的调用有时间和空间的消耗。 函数递归调用的本质的入栈与出栈操作，调用层次太多时，会导致栈溢出。（函数递归时先将父问题和子问题依次压栈，解决最低层子问题之后，再依次弹栈解决父问题。因此任何用递归解决的问题都可以利用栈改成非递归版本）。 递归中可能存在重复子问题计算。（这一点可以通过存储子问题的结果得以解决） 递归的分类？ 数组的递归 链表的递归 树的递归 数组的递归 最长公共子串 链表的递归 树的递归 894. 所有可能的满二叉树 深度优先 广度优先 图 130 200 参考 一文读懂递归算法 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-08 22:57:56 "},"DataStructAndAlgorithm/dynamicProgram.html":{"url":"DataStructAndAlgorithm/dynamicProgram.html","title":"动态规划","keywords":"","body":"回文字符串 LCS Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-10 22:02:57 "},"DataStructAndAlgorithm/sort.html":{"url":"DataStructAndAlgorithm/sort.html","title":"排序","keywords":"","body":"排序 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-06 07:50:12 "},"DataStructAndAlgorithm/tree.html":{"url":"DataStructAndAlgorithm/tree.html","title":"树","keywords":"","body":"种类 二叉树 满二叉树：每个结点恰有0个或2个子结点。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-08 22:46:52 "},"DataStructAndAlgorithm/bfsDfs.html":{"url":"DataStructAndAlgorithm/bfsDfs.html","title":"DFS & BFS","keywords":"","body":"二叉树的深度优先与广度优先 关于二叉树的深度优先遍历和广度优先遍历： DFS BFS 数据结构 栈 队列 思想 深度优先遍历的思想是从上至下，对每一个分支一直往下一层遍历直到这个分支结束，然后返回上一层，对上一层的右子树这个分支继续深搜，直到一整棵树完全遍历，因此深搜的步骤符合栈后进先出的特点. 广度优先遍历的思想是从左至右，对树的每一层所有结点依次遍历，当一层的结点遍历完全后，对下一层开始遍历，而下一层结点又恰好是上一层的子结点。因此广搜的步骤符合队列先进先出的思想。 优缺点 不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。 保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。 遍历方法 二叉树的深度优先搜索有三种遍历方法：先序遍历：根左右。中序遍历：左根右。后序遍历：左右根。除了利用栈以外，深度优先搜索也可以使用递归的方法。 图的深度优先与广度优先 深度优先遍历(Depth First Search)的主要思想是： 首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点； 当没有未访问过的顶点时，则回到上一个顶点，继续试探别的顶点，直至所有的顶点都被访问过。 广度优先遍历(Depth First Search)的主要思想是：类似于树的层序遍历。 参考： 二叉树的深度优先遍历(DFS)和广度优先遍历(BFS) Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:26:58 "},"DataStructAndAlgorithm/complex.html":{"url":"DataStructAndAlgorithm/complex.html","title":"算法复杂度","keywords":"","body":"圈复杂度 算法复杂度 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:34:26 "},"Database/database.html":{"url":"Database/database.html","title":"数据库","keywords":"","body":"Database 数据库索引 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 00:49:18 "},"DistributionSystem/distributionSystem.html":{"url":"DistributionSystem/distributionSystem.html","title":"分布式系统","keywords":"","body":"微服务 https://mp.weixin.qq.com/s/OAjcQdQxQzTRRv6q52JPNg https://mp.weixin.qq.com/s/mJ_jZZoak7uhItNgnfmZvQ zookeeper redis 强一致性 秒杀系统 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-15 08:06:58 "},"DesignPattern/designPattern.html":{"url":"DesignPattern/designPattern.html","title":"设计模式","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:21:05 "},"Project/project.html":{"url":"Project/project.html","title":"项目","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-15 07:50:44 "},"Project/flowCtrol.html":{"url":"Project/flowCtrol.html","title":"流量控制","keywords":"","body":"简介 流量控制是在通信系统中系统过载或网络拥塞时，主动减少接纳或发出的业务量，防止系统崩溃并将实际接纳业务量逼近网络处理能力的一种故障自动恢复机制。 流控的方法包括拥塞控制和过载控制两种。拥塞控制主要是配置系统每秒最大的数据报文的处理数量，当超过这个界限的时候就丢弃数据。一般是对于通信业务流程的首消息进行的，数据报的的数量对应着用户数。这个值是通过经验值来设定的，代表设备最大的接入量。 过载控制主要是根据CPU的使用量，CPU用量超过80%且持续5秒，就判断系统过载，然后根据控制理论的PID原理为不同优先级的消息分配令牌，没有获得令牌的消息就会被流控掉。 遇到的挑战 这个任务的时间比较紧，除了流控功能之外，还有许多辅助的配置命令，流控告警功能需要开发。解决方法：将问题分解，逐个开发，分批次合入代码，保证功能持续可用与功能增强。 流控功能的验证，因为一般的测试环境构造不了大话务的场景，所以需要想办法，在网上搜索人为提高CPU使用率的方法。达到流控门限，然后测试流控的功能。 验证的时候发现了已经流控掉，但是CPU和内存都冲高导致微服务挂掉，一开始不知道是哪有问题，后开看了error日志，发现一致循环打某个调用栈，内存耗尽导致。那个地方是封装的一个error接口，error里面又有error，导致存在无穷递归调用。 亮点 在着手之前，对流控功能需求和实现原理了解了一下，并且设计了全套的业务流控，包括流控的功能实现、参数配置功能、告警功能、消息数目数据统计功能等一系列的看护手段。保证了功能的健壮性。 【复盘改进】 由于时间太赶，在前期设计细节研究不够，导致部分理解偏差，实现不人性化。比如上报系统过载的告警，应该是在系统从非流控状态切换到流控状态的时候，发出一条消息，告诉周边模块本模块过载了。但是，我原始实现的是每当有一条消息被流控掉，就上报告警，这样会导致系统严重过载时界面上出现很多告警。其实就和设计衣服或者房子一样，在动手前，最好做出一个高保真的模型，避免返工。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-16 23:41:51 "},"Logic/logic.html":{"url":"Logic/logic.html","title":"智力题","keywords":"","body":"查找 赛马次数 有 25 匹马和 5 条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前 3 名。 先把 25 匹马分成 5 组，进行 5 场赛马，得到每组的排名。再将每组的第 1 名选出，进行 1 场赛马，按照这场的排名将 5 组先后标为 A、B、C、D、E。可以知道，A 组的第 1 名就是所有 25 匹马的第 1 名。而第 2、3 名只可能在 A 组的 2、3 名，B 组的第 1、2 名，和 C 组的第 1 名，总共 5 匹马，让这 5 匹马再进行 1 场赛马，前两名就是第 2、3 名。所以总共是 5+1+1=7 场赛马。 A 组：1，2，3，4，5 B 组：1，2，3，4，5 C 组：1，2，3，4，5 D 组：1，2，3，4，5 E 组：1，2，3，4，5 九球称重 有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。 将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。 对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。 药丸称重 有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。 可以从药丸的数量上来制造差异：从第 i 瓶药丸中取出 i 个药丸，然后一起称重。可以知道，如果第 i 瓶药丸重 1.1 克/粒，那么称重结果就会比正常情况下重 0.1 * i 克。 扔鸡蛋 todo!!! 一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少。 可以将楼层划分成多个区间，第一个鸡蛋 E1 用来确定 N 属于哪个区间，第二个鸡蛋 E2 按顺序遍历该区间找到 N。那么问题就转换为怎么划分区间满足最坏情况下扔鸡蛋次数最少。 E1 需要从第一个区间开始遍历到最后一个区间。如果按等大小的方式划分区间，即 E2 的遍历次数固定。那么最坏的情况是 N 在最后一个区间，此时 E1 遍历的次数最多。为了使最坏情况下 E1 和 E2 总共遍历的次数比较少，那么后面的区间大小要比前面的区间更小。具体来说，E1 每多遍历一次，E2 要少遍历一次，才使得 N 无论在哪个区间，总共遍历的次数一样。设第一个区间大小为 X，那么第二个区间的大小为 X-1，以此类推。那么 X + (X-1) + (X-2) + … + 1 = 100，得到 X (X + 1) / 2 = 100 ，即 X = 14。 老鼠喝酒试毒 一共1000瓶酒，其中一瓶有毒。如果一只老鼠喝了有毒的酒，会在一天之后死亡，那么如果给你一天时间，然你判定哪瓶酒有毒，至少需要几只老鼠？ 答案 答案是10只。这个需要使用二进制编码来解决，1000瓶酒至少需要10位二进制数来进行编码。然后取十只杯子分别代表这是个二进制数的十个位，分别将1000瓶酒倒入其编码为1的对应的杯子中。取十个老鼠分别喝十个杯子中的酒，一天之后，就可以根据喝哪些杯子的老鼠死掉来确定出有毒的那瓶酒的编码，从而确定哪瓶酒有毒。其根据就是只有有毒酒的编码对应的毒死老鼠的杯子位置。这个题目就是利用了二进制编码的一些特性。 国王有10000桶酒，已知一桶酒有毒，喝了之后一定会在23-24小时内死亡（例如0点喝，会在23-第二天0点这个时间段死亡）。现在国王要在48小时后举办一个宴会，需要用罪犯实验，请问最少几个罪犯。（可以混合酒） 如果是常规利用二进制解题的话，那就需要14个犯人，2^14=16384>10000，但是这样一来死亡时间这个条件就用不到，也不是最优解。 应该利用酒死的时间是固定的，一个罪犯像上面那样可以表示成25种状态，三个罪犯就可以表示25 x 25 x25种状态，超过10000了，所以只需要三个罪犯。 拓展 还有一些其他的题目也使用这些特性，比如使用特殊的位运算，一般使用比较多的位运算就是与、或和异或。 这样，就可以对应到现实生活中的一些为题，比如一个类似的问题原本我们想需要用900多台服务器来解决，经过这样分析后就可以使用10台服务器来解决，大大节约了成本。 计量 用绳子计时 15 分钟 给定两条绳子，每条绳子烧完正好一个小时，并且绳子是不均匀的。问要怎么准确测量 15 分钟。 点燃第一条绳子 R1 两头的同时，点燃第二条绳子 R2 的一头； 当 R1 烧完，正好过去 30 分钟，而 R2 还可以再烧 30 分钟； 点燃 R2 的另一头，15 分钟后，R2 将全部烧完。 得到指定容量的水 有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。 可以理解为用若干个 5 和 3 做减法得到 4。 不能从 3 做减法得到 4，那么只能从 5 做减法得到 4，即最后一个运算应该为 5 - 1 = 4，此时问题转换为得到 1 升的水； 1 升的水可以由 3 做减法得到，3 - 2 = 1，此时问题转换为得到 2 升的水； 5 - 3 = 2。 一个5L，一个6L的瓶子，要得到3L的水，问什么方法 答案 6-5=1 1L水放在5L那个瓶里面，然后再装6L水，往5L（里面已经有1L）里面倒，这样就会剩下2L水在6L里面，再把2L水放在5L里面，再装一次，不就可以6L那里到处3L水到5L里面，自己就剩下3L了 红白帽子推理 一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其它人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？ 答案 三个人 若是两个人，设A、B是黑帽子,第二次关灯就会有人打耳光。原因是A看到B第一次没打耳光，就知道B也一定看到了有带黑帽子的人，可A除了知道B带黑帽子外，其他人都是白帽子，就可推出他自己是带黑帽子的人！同理B也是这么想的，这样第二次熄灯会有两个耳光的声音。 如果是三个人，A,B,C。A第一次没打耳光，因为他看到B,C都是带黑帽子的；而且假设自己带的是白帽子，这样只有BC戴的是黑帽子；按照只有两个人带黑帽子的推论，第二次应该有人打耳光；可第二次却没有...于是他知道B和C一定看到了除BC之外的其他人带了黑帽子，于是他知道BC看到的那个人一定是他，所以第三次有三个人打了自己一个耳光 拓展: N个人是黑帽子，就会在第N天，有N个人打自己一个耳光。 吃药片 一个是两种药片，每种有两个，一个人需要早上吃两种药片各一个，现在这四个药片混在一起了这个人什么方法吃。 答案 把所有的4颗药丸都切开成相等的两半，然后早上和晚上，分别吃掉每颗药丸的一半 飞机加油 本体图解参考：https://blog.csdn.net/hinyunsin/article/details/6632062 已知： 每个飞机只有一个油箱，飞机之间可以相互加油（注意是相互，没有单独的加油机），一箱油可供一架飞机绕地球飞半圈。问题：为使至少一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机？（所有飞机从同一机场起飞，而且必须安全返回机场，不允许中途降落，中间没有飞机场） 答案 分为3架飞机5架次和3架飞机6架次 3架飞机6架次 image （上图）ABC 3架同时起飞 image （上图）1/8处，C给AB加满油，C返航。此时飞机的油量分别是：A: 3/4, B: 3/4, C: 3/4。此时C分别给A和B加满油，三架飞机当前油量分别是：A: 1, B: 1, C: 1/4。C返回机场。A、B继续向前飞行。 image （上图）1/4处，B给A加满油，B返航，A到达1/2处，此时C已经返回机场，三家飞机此时油量分别是：A: 3/4, B: 3/4, C: 0。此时B给A加满油，C加满油，此时三架飞机的油量分别是：A: 1, B: 1/2, C: 1。然后B返回机场，A继续向前飞行。 image （上图）当A飞行至半圈位置时，B已经返回机场并且加满了油（假设加油时间为0），此时，B和C沿逆时针方向飞行，三架飞机当前油量分别是：A: 1/2, B: 1, C: 1。A继续向前飞行。 image （上图）当A飞行至另外半圈的1/4位置时，三架飞机剩余油量分别是：A: 1/4, B: 3/4, C: 3/4。此时，C给B加满油。此时三架飞机油量分别是：A: 1/4, B: 1, C: 1/2。C返回机场，B和A继续向前飞行。 image 当A飞行至另外半圈的1/2位置时，C已经返回机场，A和B相遇，此时三架飞机剩余油量分别是：A: 0, B: 3/4, C: 0。B给A加1/4的油，三架飞机剩余油量：A: 1/4, B: 1/2, C: 1。C加满油从机场逆时针飞出，B返回机场，A继续向前飞行。 image （上图）当A飞行至另外半圈的3/4位置时，A和C相遇。此时三架飞机的油量分别是：A: 0, B: 1/4, C: 3/4。C给A加1/4的油，此时三架飞机的油量分别是：A: 1/4, B: 1/4, C: 1/2。C掉头返回机场，A和B继续向前飞行。 image （上图）三架飞机顺利回到机场！ 3飞机5架次 image （1）3 架飞机同时从机场出发，飞行八分之一周（A点），各耗油四分之一。此时某架飞机给其余两架补满油，自己返回基地； （2）另一架飞机和目标机结伴，飞至四分之一周（B点），给目标机补满油，自己返回； （3）目标机独自飞行半周（C点）； （4）与从基地反向出发的一架飞机相遇，2 机将油平分，飞至最后八分之一处（D点）； （5）与从基地反向出发的另一机相遇，各分四分之一油，返回。 参考： 面试智力题集锦 75道程序员面试逻辑题和答案 精选程序员面试常问的逻辑题 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-20 13:30:21 "}}