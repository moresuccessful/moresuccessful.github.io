{"./":{"url":"./","title":"Introduction","keywords":"","body":"Welcome To Moresuccessful Zone! 世上没有白费的努力，成功不必在我，而功力必不唐捐。 ——胡适 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-04 08:54:37 "},"ComputerNetworks/computerNetworks.html":{"url":"ComputerNetworks/computerNetworks.html","title":"计算机网络","keywords":"","body":"计算机网络 计算机网络7层模型 网络分层的意义在于便于管理。 7层模型中，上三层为用户提供服务；下四层为数据传输提供服务，且物理层才是真正用于传输实际数据。 网络层次 协议 功能 数据单位 应用层 HTTP，FTP 1. 用户接口 APDU应用协议数据单元 表示层 1. 将数据翻译成01（英文ASCII，中文GB2312，图片jpg，音频mp3等）。2. 加密、压缩 PPDU表示层协议数据单元 会话层 1. 确定网络数据是否要经过远程会话（如果不需要进行远程传递，则不会发给传输层，而是直接让磁盘储存。） SPDU会话协议数据单元 传输层 TCP,UDP 1. 确定端口号（不同端口号对应不同的服务）2. 确定传输协议可靠/不可靠3. 传输前的错误检测，流控 TPDU 数据段 网络层 1. IP2. ICMP(互联网控制报文协议, ping操作应用此协议)3. IGMP(互联网组管理协议) 1. 提供逻辑地址（IP）、选路 IP数据报文保存IP地址信息 数据链路层 CSMA,CDMA，ARP 1. 成帧2. 用MAC地址访问文件（MAC用于局域网）3. 错误检测与修正4. 采用载波监听多路访问模式 MAC 帧保存了硬件MAC地址 物理层 1. 负责设备之间比特流的传输，物理接口、电气特性等（网线、网卡） 01比特流 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-01 10:00:40 "},"ComputerNetworks/applicationLayer.html":{"url":"ComputerNetworks/applicationLayer.html","title":"应用层","keywords":"","body":"应用层概述 为网络应用（主机上正在运行的进程）提供一个与表示层交互的接口。 协议 基于TCP的应用层协议 HTTP: (Hypertex Transport Protocol, 超文本传输协议 ) 从web服务器传输超文本到本地浏览器。 FTP: (File Transfer Protocol，文件传输协议) 用于下载文件、上传主页，使用21端口。 Telnet: (远端登录协议) 基于DOS模式下的远程连接到计算机的通信服务，使用23端口。 SMTP: (Simple Mail Transmission Protocol, 简单邮件传输协议) 用于发送邮件，使用25端口。 POP3: 用于接收邮件，只要主机有使用POP3协议的程序(e.g. Foxmail/Outlook）就可以收到例如163邮箱的邮件了，使用110端口。 基于UDP的应用层协议 DNS: (Domain Name System, 域名解析服务) 用于将域名（网址）转换为IP地址，使用53号端口。 SNMP: (Simple Network Management System, 简单网络管理协议) 用来管理IP网络的网络节点（服务器、交换机、路由器、HUBs等）。通过SNMP接收随机消息以及事件报告，网络管理系统能获知网络出现的问题，并规划网络增长。SNMP的前身是简单网关监控协议SGMP。（由于网络设备很多，基于UDP的无连接服务就体现出优势），使用161号端口。 TFTP: (Trival File Transfer Protocol, 简单文件传输协议) 。用于客户机和服务器之间简单的开销不大的文件的传输，只能从文件服务器上读写文件，不具备FTP所具有的一些功能，如不能列出目录、不能进行验证，传输8位数据。使用69端口。 HTTP HTTP 请求 http请求报文如下。（图来源CSDN） 请求方法 请求方法的幂等性：一个方法重复执行多次，产生的效果是一样的，那么这个方法就是幂等的。 请求方法的安全性：不会改变资源的方法是安全的，有GET，HEAD，OPTIONS。 HTTP 请求方法有8种： 请求方法 含义 幂等性 GET 完整请求一个资源。不对服务器产生任何影响 是 HEAD 和GET类似，区别在于仅请求响应首部，不需要传输任何实际内容。 是 OPTIONS 返回请求的资源所支持的方法。 是 PUT 上传文件，将实体部分的数据直接替换到服务器的资源上。 是 PATCH 对文件内容做部分修改。 否 POST 提交表单。这种方法会影响服务器。 否 DELETE 删除资源。 是 TRACE 要求目标服务器返回原是的HTTP请求的内容，可用来查看中间服务器对HTTP请求的影响，可用来追踪一个资源请求中间所经过的代理。 HTTP响应 http响应报文如下，包括响应头与响应体两部分。（图来源百度百科） 状态码 状态码（status code）和状态码描述（description）位于HTTP响应报文的响应行（status line）中。 状态类型状态码&描述含义 1XX 信息 1XX是一种临时状态，表示接收了消息，仍在处理中，常用于调试场景。 100 Continue通知客户端部分请求已经被服务端接收，客户端应继续发送请求的剩余部分。 2XX 成功 200 Ok请求成功，报文中包含实体主体。类似于做问答题 204 No Content请求成功，但报文中不包含实体主体。类似于做判断题 206 Partial Content请求GET的资源是服务器资源的一部分，那么响应报文则返回请求的那一部分的资源。例如下载场景的断点续传。 3XX重定向 请求返回301 302 303 时，几乎所有浏览器都会把原先的POST请求改为GET请求。 301 Moved Permanently资源被永久重定向，并返回重定向后的新URL 302 Move Temporarily资源临时重定向，返回临时的URL 303 See Other和302类似，并增加了一个附加条件，需要用GET方法访问临时重定向的URL,且303响应禁止被缓存。 304 Not Modified通知客户端资源未改变，可直接使用本地缓存，且服务端不会返回实体主体（相当于重定向到本地缓存）这种响应通常是请求带有附加条件，如请求一段时间内未变更的资源。 307 Temporary Redirect与302类似，区别在于禁止将POST方法转为GET方法。 4XX客户端错误 客户端出错导致请求无法被处理 400 Bad Request请求中有语法或参数错误 401 Unauthorized请求头中Authorization身份认证字段有误，未授权 403 Forbidden无访问权限，服务器拒绝了请求，具体原因在响应报文实体主体中给出，也可能不给出。 404 Not Found请求的资源未找到 5XX服务端错误 500 Internal Server Error内部服务器故障 502 Bad Gateway作为代理（客户端和服务端的中转，转发双方的请求，使用http协议）或网关（与代理类似，区别在于与源服务器之间可以使用非http协议）的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 Service Unavailable服务器由于维护、升级、过载等原因暂时无法响应 504 Gateway Timeout作为网管或代理的服务器访问超时。 HTTPS cookie v.s. session cookie存储在浏览器上，最大存储量为4KB。session存储在服务器端，大小无限制。 cookie可以轻松访问，但是session不能，因此session更安全。 设置cookie时间可使cookie过期，而删除回话需要执行session destroy操作。 参考 百度百科-HTTP状态码 巧记HTTP状态码 http状态码竟然可以这样记 HTTP请求的完全过程 幂等性的含义和 HTTP请求方法的幂等性 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-03 15:22:09 "},"ComputerNetworks/transportLayer.html":{"url":"ComputerNetworks/transportLayer.html","title":"传输层","keywords":"","body":"三次握手 四次挥手 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:38:32 "},"OperatingSystem/operatingSystem.html":{"url":"OperatingSystem/operatingSystem.html","title":"操作系统","keywords":"","body":"操作系统 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 11:00:37 "},"OperatingSystem/processAndThread.html":{"url":"OperatingSystem/processAndThread.html","title":"X程","keywords":"","body":"进程与线程 进程 线程 定义 进程是指程序在数据集上的一次运行，是系统资源分配和调度的基本单元； 线程是进程的一个实体，是CPU调度的基本单元 资源分配与CPU调度 1. 进程之间不共享资源2. 在没有线程的操作系统中，进程既是资源分配的基本单位，又是调度的基本单位3. 一个进程至少有一个线程，即主线程，也可以有多个线程协同工作 1. 线程并不拥有资源，只是使用他们，进程是资源分配和拥有的基本单元。2. 在有线程的操作系统中，进程是资源分配的基本单位，线程是调度的基本单元3. 线程是指进程内的一条执行线路，或者说是进程中可执行代码的单独单元，它是操作系统的基本调度单元。4. 动态性：线程也是程序在相应数据集上的一次执行，由创建而产生，至撤销而消亡，有其生命周期 组成 进程是PCB（进程管理块）结构与程序和数据的组合 通讯 由于同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核 进程 进程间通信 1）消息队列（Message） 消息队列是消息的链接表。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 2）共享内存 使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 3）管道（Pipe）及有名管道（named pipe） 管道可用于具有亲缘关系进程间的通信（父子进程），有名管道克服了管道没有名字的限制，它还允许无亲缘关系进程间的通信； 4）信号（Signal） 信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身； 5）信号量（semaphore） 资源计数器。主要作为进程间以及同一进程不同线程之间的同步手段。 6）套接口（Socket） 更为一般的进程间通信机制，可用于不同机器之间的进程间通信。 fork() 进程的fork()方法用于产生子进程，产生于系统中没有线程的年代。fork操作会进行4步： 为子进程分类内存块和数据结构； 将父进程的部分数据结构内容复制给子进程； 将子进程加入到系统进程列表中； fork()返回，开始调度器调度。 fork() 在父进程中返回子进程的PID，在子进程中返回0，fork出错时返回-1. 当系统中进程数超过系统上限或内存不足时可能出现fork出错的情形。 线程 线程安全 LINK 管程 协程 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-16 14:44:34 "},"DataStructAndAlgorithm/dataStructAndAlgorithm.html":{"url":"DataStructAndAlgorithm/dataStructAndAlgorithm.html","title":"数据结构与算法","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 10:55:51 "},"DataStructAndAlgorithm/leetcode.html":{"url":"DataStructAndAlgorithm/leetcode.html","title":"Leetcode","keywords":"","body":"目录 42. 缺失的第一个正数 46. 全排列 94. 二叉树的中序遍历 96. 不同的二叉搜索树 102. 二叉树的层次遍历 105. 从前序与中序遍历序列构造二叉树 106. 从中序与后序遍历序列构造二叉树 144. 二叉树的前序遍历 145. 二叉树的后序遍历 153. 寻找旋转排序数组中的最小值 200. 岛屿数量 403. 青蛙过河 698. 划分为k个相等的子集 779. 第K个语法符号 794. 有效的井字游戏 889. 根据前序和后序遍历构造二叉树 894. 所有可能的满二叉树 912. 排序数组 923. 三数之和的多种可能 993. 二叉树的堂兄弟节点 1028. 从先序遍历还原二叉树 1277. 统计全为 1 的正方形子矩阵 1278. 分割回文串 III 42. 缺失的第一个正数 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 与剑指 offer第三题类似，不同之处在于可能出现负数或大于数组长度n的数。对于这样的数跳过即可，对其他1～n的数换到下标0～n-1的位置。如果数组内数据为[1,2,...,n], 那么第一个未出现的正数是n+1，所以第一个未出现的正数范围是1～n+1。 nums[i] == i+1 符合置换条件，不需要交换。 nums[i] == nums[nums[i]-1] 两个交换值相等的情况下，会产生死循环，所以也无需交换，继续下一个。 func firstMissingPositive(nums []int) int { n := len(nums) for i := 0; i n || nums[i] == i+1 || nums[i] == nums[nums[i]-1]){ i++ } if i46. 全排列 给定一个没有重复数字的序列，返回其所有可能的全排列。 TAG：【递归】【回溯】 假设数字序列为[0...n-1],首先是确定第一个数，将序号为0～n-1的数分别与第一个数交换位置。交换完了之后要恢复数组原貌，再确定第二个数，将第二个数后面所有数字和第二个数交换。如此，直到确定了所有数之后就得到了一个结果。 注意这里储存结果的二维数组必须得使用指针，否则结果传不出来。 如果不恢复原貌，得到的结果会有重复，并且得到的结果不全。 交换一定要从start开始，而不是start+1， func permute(nums []int) [][]int { var results [][]int backTrace(nums, &results,0) return results } func backTrace(nums []int, results *[][]int, start int){ if start == len(nums){ *results = append(*results,append([]int{},nums...)) } for i := start; i 96. 不同的二叉搜索树 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ TAG：【动态规划】 本题是一维的动态规划算法，构造result[i]代表1～i组成的二叉搜索树的种类。可以知道m~n的二叉搜索树的种类等于1～n-m+1为节点组成的二叉搜索树。又根据二叉搜索树的性质，root左边的数小于root，右边的数大于root。因此，1～i为节点的二叉搜索树的种类是以1～i分别为root时左右两边二叉树种类的乘积。 func numTrees(n int) int { var result = make([]int, n+1) result[0] = 1 result[1] = 1 for i:=2;i153. 寻找旋转排序数组中的最小值 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。你可以假设数组中不存在重复元素。 旋转数组前半部分所有数字值大于后半部分，需要找到旋转点。所以判断一截数组，如果第一个元素大于最后一个元素，说明这截数组仍然是旋转数组。 要判断end-start==1的情况，应为当这种情况下，mid=(start+end)/2会出现mid==start，从而造成死循环。 本题假设没有重复数字，当有重复数字时，会有nums[start] == nums[end]==nums[mid]的情况，这个时候需要顺序查找最小值。 func findMin(nums []int) int { if len(nums) == 0 { return 0 } start, end :=0, len(nums)-1 for nums[start] > nums[end]{ if end -start == 1{ return nums[end] } mid := (start + end)/2 if nums[start] >= nums[mid] { end = mid } else if nums[start] 200. 岛屿数量 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 TAG:【图】【递归】【深度优先】【广度优先】 深度优先搜索：关键词递归 从某个点开始，如果值是1，说明至少有1个岛，岛屿的数量+1. 然后从这个点开始深度优先深度从上下左右四个方向开始深度优先搜索，直到遍历到值是0的点，将之前遍历到的值是1的点改成0. 知道所有点被遍历完为止。 广度优先搜索：关键词队列 与深度优先搜索一样，不同点在于，把当前节点周围值为1的节点都存储下来，依次遍历直到邻接点是0为止。 // 深度优先搜索 func numIslands(grid [][]byte) int { result := 0 for i := 0; i = 0 && (*grid)[x-1][y] == '1' { (*grid)[x-1][y] = '0' dfs(grid, x-1, y) } if x+1 = 0 && (*grid)[x][y-1] == '1' { (*grid)[x][y-1] = '0' dfs(grid, x, y-1) } if y+1 // 广度优先算法 func numIslands(grid [][]byte) int { if len(grid) == 0{ return 0 } result := 0 neigbor := make([]int, 0) row := len(grid) col:=len(grid[0]) for i := 0; i 0{ x,y:=neigbor[0]/col,neigbor[0]%col neigbor = neigbor[1:] if x-1 >= 0 && grid[x-1][y] == '1' { grid[x-1][y] = '0' neigbor = append(neigbor, (x-1)*col+y) } if x+1 = 0 && grid[x][y-1] == '1' { grid[x][y-1] = '0' neigbor = append(neigbor, x*col+y-1) } if y+1 403. 青蛙过河 给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。实例：输入[0,1,3,5,6,8,12,17]，输出true。 TAG：【动态规划】 本题涉及二维的动态规划 dp[i][j] 表示在stones[i]上可以跳跃j步。 当计算到dp[i][j]， i=n-1且存在为true的j时，说明前一个节点也可以跳j步到达这最后一个石头上。 func canCross(stones []int) bool { var dp = make([][]bool, len(stones)) // 在stones[i]上可以跳跃j步 for i := range dp { dp[i] = make([]bool, len(stones)) } dp[0][1] = true for i := 1; i = len(stones) || !dp[j][dis] {continue}// dis的范围判断是为了dp[j][dis]下标不越界 if i == len(stones)-1 {return true} // 成功判定 dp[i][dis] = true // 更新dp数组 if dis-1 > 0 { dp[i][dis-1] = true} if dis+1 698. 划分为k个相等的子集 给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4 输出： True 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。 TAG：【数组】【递归】【动态规划】 func canPartitionKSubsets(nums []int, k int) bool { total := 0 for i := range nums { total += nums[i] } if k = 0; i-- { if nums[i] > sum { return false } if nums[i] == sum { lastIdx-- k-- } if nums[i] 779. 第K个语法符号 在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始） TAG：【数组】【递归】 按照递归2步走：终止条件，递归式。 func kthGrammar(N int, K int) int { if N794. 有效的井字游戏 用字符串数组作为井字游戏的游戏板 board。当且仅当在井字游戏过程中，玩家有可能将字符放置成游戏板所显示的状态时，才返回 true。该游戏板是一个 3 x 3 数组，由字符 \" \"，\"X\" 和 \"O\" 组成。字符 \" \" 代表一个空位。 以下是井字游戏的规则： 玩家轮流将字符放入空位（\" \"）中。 第一个玩家总是放字符 “X”，且第二个玩家总是放字符 “O”。 “X” 和 “O” 只允许放置在空位中，不允许对已放有字符的位置进行填充。 当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。 当所有位置非空时，也算为游戏结束。 如果游戏结束，玩家不允许再放置字符。 TAG：【数组】【二维】 本题就是找规律，分为以下3个特殊情形： X棋子先下，因此X的数量比O多1个，或者与O相等，其他情况说明不符合游戏规则，返回false。 当X满足赢的条件的时候，X数量比O多1，否则返回false。 当O满足赢的条件的时候，O数量和X一样多，否则返回false。 func validTicTacToe(board []string) bool { cntO,cntX:=count(board) if cntX-cntO!= 1 && cntX-cntO!=0{ // 条件1判断 return false } if win(board,'X') && cntX-cntO!=1{ // 条件2判断 return false } if win(board,'O') && cntX!=cntO{ // 条件3判断 return false } return true } func count(board []string)(int,int){ // 获取X和O棋子的个数 var cntO, cntX int for j := 0; j 894. 所有可能的满二叉树 满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。答案中每个树的每个结点都必须有 node.val=0。你可以按任何顺序返回树的最终列表。 TAG：【递归】【树】 递归的思路，N个节点时，根节点占用一个节点，左右子孩子占有N-1个节点，由于是满二叉树，因此如果存在左孩子，必定需要有右孩子，反之亦然。遍历左孩子占用节点树为1～N-2的情况，得出左孩子可能的根节点的数据，将这些根节点接上原始root，则得到了不同的目标答案。 核心在于构建递归函数的入参和出参。理论上，递归函数是可以不设置任何出参的，可以在入参中存储结果。（需要存储结果的原因在于存储下子问题的解，避免重复子问题计算）。由于目标结果是树的头节点的切片[]*TreeNode，因此如果我们需要存在子问题的解，则需要存节点数为1～N范围的结果值，因此，存储结果的类型设置为[][]*TreeNode. func allPossibleFBT(N int) []*TreeNode { if N == 0 { return nil } store := make([][]*TreeNode, N+1) findTree(N, &store) return store[N] } func findTree(N int, store *[][]*TreeNode) { if N == 1 { (*store)[N] = []*TreeNode{&TreeNode{0, nil, nil}} return } result := make([]*TreeNode, 0) for i := 1; i 912. 排序数组 给定一个整数数组 nums，将该数组升序排列。 TAG：【排序】【数组】 快速排序: func quickSort(nums []int){ partition(nums, 0, len(nums)-1) } func partition(nums []int, start, end int){ if start >= end{ return } var i, j = start, end pivot:=nums[start] for i =pivot{ nums[j] = nums[i] j-- break } } } nums[i] = pivot // 置位 partition(nums, start, i-1) // 分治 partition(nums, i+1, end) } 堆排序： func heapSort(nums []int){ for i:=len(nums)/2-1;i>=0;i--{ // 从最后一个非叶子结点开始调整，构造一个完成最大堆 heaplify(nums, i, len(nums)-1) } for j:=len(nums)-1;j>=1;j--{// 将堆定最大元素取出，将堆最后一个叶子结点放在堆定，再调整 nums[0],nums[j] = nums[j],nums[0] heaplify(nums,0,j-1) } } func heaplify(nums []int, start, end int){// 堆的调整 for i := start; inums[i] && (right > end || nums[right]nums[i]{ nums[right],nums[i] = nums[i],nums[right] i=right }else{ break } } } 923. 三数之和的多种可能 给定一个整数数组 A，以及一个整数 target 作为目标值，返回满足 i 【三指针】 由于数字大小范围为0～100，首先采用桶排序，对A数组中的数字出现的次数进行统计，record[i]表示数字i出现的次数，如果没有数字i，则record[i]=0。 定好第一个数，另外两个数分别用首尾指针确定，由于可能出现3个数字中有相同的数的情况，首指针从第一个数的位置开始，首尾指针可以相等。 注意判断特殊情况，第一个数和第二个数相等，第二个数和第三个数相等的情况。 func threeSumMulti(A []int, target int) int { const maxResult = 1000000007 const maxNum = 100 var record = make([]int, maxNum+1) for i := range A { record[A[i]]++ } result := 0 for i := 0; i = j; { if record[j] == 0 || j+k left { k-- continue } if i = 2 { result = (result + ((record[i]*(record[i]-1))/2)*record[k]) % maxResult } else if i = 2 { result = (result + ((record[j]*(record[j]-1))/2)*record[i]) % maxResult } else if record[i] >= 3 { result = (result + ((record[j] * (record[j] - 1) * (record[j] - 2)) / 6)) % maxResult } j++ k-- } } return result } 993. 二叉树的堂兄弟节点 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 TAG：【树】 递归分别求x和y的深度和父节点的值。 func isCousins(root *TreeNode, x int, y int) bool { var xParent, yParent, xdepth, ydepth int xflg:=isChild(root,x,&xParent,&xdepth) yflg:=isChild(root, y,&yParent,&ydepth) if !xflg || !yflg || xParent == yParent || xdepth!=ydepth { return false } return true } func isChild(root *TreeNode, val int, parent *int, depth *int) (bool){ if root == nil { return false} if (root.Left != nil && root.Left.Val== val) || (root.Right != nil && root.Right.Val== val){ *parent = root.Val *depth+=1 return true } if isChild(root.Left, val, parent, depth) || isChild(root.Right, val, parent,depth){ *depth+=1 return true } return false } 1277. 统计全为 1 的正方形子矩阵 给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。 输入：matrix = [ [0,1,1,1], [1,1,1,1], [0,1,1,1] ] 输出：15 解释： 边长为 1 的正方形有 10 个。 边长为 2 的正方形有 4 个。 边长为 3 的正方形有 1 个。 正方形的总数 = 10 + 4 + 1 = 15. 按照边长1～min(row,col)的小正方形的情况，暴力求解。 1278. 分割回文串 III 给你一个由小写字母组成的字符串 s，和一个整数 k。 请你按下面的要求分割字符串： 首先，你可以将 s 中的部分字符修改为其他的小写英文字母。 接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。 请返回以这种方式分割字符串所需修改的最少字符数。 输入：s = \"abc\", k = 2 输出：1 解释：你可以把字符串分割成 \"ab\" 和 \"c\"，并修改 \"ab\" 中的 1 个字符，将它变成回文串。 dp[i][j] = min(dp[i][j],dp[m][j-1]+cost[m+1][i]), m=1...i-1 dp[i][j] 代表字符串s前i个字符分成j个子串需要修改的最少字符数，cost[m][n]代表字符串第m到n个字符的子串变成回文需要修改的最小字符数。（下标均为从1开始） func initCost(s string) [][]int { // cost[i][j]表示第i～j字符段成为回文需要变化的次数，下标0开始 var cost = make([][]int, len(s)) for i := 0; i Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-13 22:37:43 "},"DataStructAndAlgorithm/tree.html":{"url":"DataStructAndAlgorithm/tree.html","title":"树","keywords":"","body":"二叉树分类 满二叉树：每个结点恰有0个或2个子结点。 搜索二叉树： 左叶子 二叉树的遍历 树的遍历方式分为深度优先搜索遍历（DFS）与宽度优先搜索遍历（BFS）。 DFS采用深度作为优先级，从根开始一直遍历到某一确定节点，再返回根到达另外一个分支。DFS又可以根据树的根节点遍历的顺序分为前序遍历，中序遍历与后序遍历。二叉树的遍历还涉及根据遍历结果重建二叉树。 BSF按照高度层次逐层遍历树，层次高的节点优先于层次低的的节点被遍历。BFS包含树的层序遍历 DFS 前序遍历 设置一个栈nodeSaver一次存储根节点、右节点、左节点。 下一次遍历，栈顶弹出上一次的左节点Left，并继续压栈Left的右、左节点。 如此，先遍历了根和左节点，最后遍历右节点。 func preorderTraversal(root *TreeNode) []int { if root == nil { return nil } nodeSaver, res := []*TreeNode{root}, []int{} // 栈初始化 for len(nodeSaver) > 0 { curNode := nodeSaver[len(nodeSaver)-1] nodeSaver = nodeSaver[:len(nodeSaver)-1] // 根节点出栈 res = append(res, curNode.Val) if curNode.Right != nil { nodeSaver = append(nodeSaver, curNode.Right) // 右节点压栈 } if curNode.Left != nil { nodeSaver = append(nodeSaver, curNode.Left) // 左节点压栈 } } return res } 中序遍历 设置一个栈用于存储当前节点往下遍历的所有的根和左子树的节点。 当当前节点遍历到末端（nil）时，开始弹栈，依次将左子树和根弹出，最后随后当前根节点的右叶子。 func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } var nodeSaver []*TreeNode var res []int for cur := root; cur != nil || len(nodeSaver) > 0; { for cur != nil { nodeSaver = append(nodeSaver, cur) // 当前节点向下的所有根、左叶子压栈 cur = cur.Left } cur = nodeSaver[len(nodeSaver)-1] nodeSaver = nodeSaver[:len(nodeSaver)-1] // 左叶子/根出栈 res = append(res, cur.Val) cur = cur.Right // 处理右叶子 } return res } 后序遍历 方法与前序遍历类似，前序遍历的顺序是根左右；后序顺序是左右根，后序结果逆序之后是根右左。 因此设置节点压栈顺序是根、左、右，存储结果的时候，需要把当前节点的值放在前面（即结果需要逆序） func postorderTraversal(root *TreeNode) []int { if root == nil{ return nil } nodeSaver, res := []*TreeNode{root}, []int{} // 栈初始化 for len(nodeSaver) > 0 { cur := nodeSaver[len(nodeSaver)-1] nodeSaver = nodeSaver[:len(nodeSaver)-1] // 根节点出栈 res = append([]int{cur.Val}, res...) // 结果逆序存储 if cur.Left != nil{ nodeSaver = append(nodeSaver, cur.Left) // 左节点压栈 } if cur.Right!= nil{ nodeSaver = append(nodeSaver, cur.Right) // 右节点压栈 } } return res } 重建二叉树 两种遍历序列可以确定二叉树的结构，但当且仅当其中一种遍历方式是中序遍历时，才能唯一确定一个二叉树结构。 下面给出了由前中序构造二叉树, 由中后序构造二叉树 构造一棵唯一的二叉树；和由前后序构造二叉树构造可能的二叉树的解法；以及仅由变种的前序遍历恢复二叉树，翻转二叉树以匹配先序遍历。 由前中序构造二叉树 采用递归,下面算法的前提是树中没有重复元素。前序遍历第一个节点是根节点，在中序遍历中找到根节点的位置，前半部分则是根的左叶子，后半部分是根的右叶子。 func buildTree(preorder []int, inorder []int) *TreeNode { if a, b := len(preorder), len(inorder); a != b || a == 0{ return nil } root:=&TreeNode{preorder[0],nil,nil} idx := 0 for i := range inorder{ if inorder[i] == preorder[0]{ idx = i break } } root.Left = buildTree(preorder[1:idx+1],inorder[:idx]) root.Right = buildTree(preorder[idx+1:],inorder[idx+1:]) return root } 由中后序构造二叉树 几乎与由前中序构造二叉树解法完全一致，使用递归即可。 func buildTree(inorder []int, postorder []int) *TreeNode { if a,b := len(inorder), len(postorder); a != b || a == 0 { return nil } rootVal:=postorder[len(postorder)-1] var idx int for idx=0;idx由前后序构造二叉树 前序和后序遍历不能唯一确定一个二叉树结构，下面算法给出了可能的一种二叉树。 前序的第一个节点和后序的最后一个节点是根节点，据此得出递归后的pre和post入参。 func constructFromPrePost(pre []int, post []int) *TreeNode { if a, b := len(pre), len(post); a != b || a == 0{ return nil } root := &TreeNode{Val:pre[0]} if len(pre) == 1{ return root } next := pre[1] // 下一个根节点 var idx int for idx = 0; idx从变种先序遍历还原二叉树 我们从二叉树的根节点 root 开始进行深度优先搜索。在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。如果节点只有一个子节点，那么保证该子节点为左子节点。给出遍历输出 S，还原树并返回其根节点 root。例：输入：\"1-2--3--4-5--6--7\" 输出： 1 / \\ 2 5 / \\ / \\ 3 4 6 7 定义了slashCount来定义数字A前面的横杠的个数。这个个数其实就代表了数字A在二叉树种的层次。（根节点是第0层）。由于使用Split函数会吞掉一个横杠，所以初始化的时候设置slashCount为1，补齐吞掉的横杠。 nodeSave中存的节点，由于是前序遍历，所以可以保证任何时刻，nodeSave中存的节点，每层二叉树只有1个。所以每次在处理一个新节点之前，前将多余的左叶子节点去掉，只保留nodeSave当前层以上的节点。 func recoverFromPreorder(S string) *TreeNode { if len(S) == 0 {return nil} splitSeg := strings.Split(S, \"-\") rootVal, _ := strconv.Atoi(splitSeg[0]) root := &TreeNode{Val: rootVal} // 第一个元素是根 slashCount, nodeSaver := 1, []*TreeNode{root} for i := 1; i 翻转二叉树以匹配先序遍历 给定一个有 N 个节点的二叉树，每个节点都有一个不同于其他节点且处于 {1, ..., N} 中的值。通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。我们的目标是翻转最少的树中节点，以便树的前序遍历行程与给定的行程 voyage 相匹配。 如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表 [-1]。例如：输入二叉树 1 /\\ 2 3 voyage=[1,3,2], 则输出 [1] ``` ## BFS ### 层序遍历 1. 当层序遍历的结果只需要存在一维数组中时，只需要一个一维数组存储树的节点，一直往后面追加节点即可。 2. 有的层序遍历，如下面代码，当结果需要存到二维数组中，即每一层元素单独一个一维数组时，则需要一个二维数组存储树的节点，并用curIdx记录当前层。这里要注意容易错的点是，删除slice第一个元素的时候，不能使用```arr = append(arr, arr[1:]...)```, 这样并不是从头开始append，所以并不会删除第一个元素，反而arr的元素一直在增加。直接```arr = arr[1:]```即可。(微软2019二面面试题，就是在这个地方错了) func levelOrder(root *TreeNode) [][]int { if root == nil { return nil } curIdx := 0 nodeSaver, curLayer, res := [2][]*TreeNode{{root}, {}}, []int{}, [][]int{} for len(nodeSaver[curIdx]) > 0 { curNode := nodeSaver[curIdx][0] curLayer = append(curLayer, curNode.Val) if curNode.Left != nil { nodeSaver[1-curIdx] = append(nodeSaver[1-curIdx], curNode.Left) } if curNode.Right != nil { nodeSaver[1-curIdx] = append(nodeSaver[1-curIdx], curNode.Right) } nodeSaver[curIdx] = nodeSaver[curIdx][1:] // 删除第一个元素，容易出错 if len(nodeSaver[curIdx]) == 0 { res = append(res, curLayer) curLayer = make([]int, 0) // curLayer 存储当前层的元素 curIdx = 1 - curIdx } } return res } ``` Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-16 09:19:24 "},"DataStructAndAlgorithm/string.html":{"url":"DataStructAndAlgorithm/string.html","title":"字符串","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-08 10:28:13 "},"DataStructAndAlgorithm/sort.html":{"url":"DataStructAndAlgorithm/sort.html","title":"排序","keywords":"","body":"排序 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-06 07:50:12 "},"DataStructAndAlgorithm/recursion.html":{"url":"DataStructAndAlgorithm/recursion.html","title":"递归","keywords":"","body":"简介 什么时候用递归？ 可以找到子问题的退出条件。 一个问题可以分解为子问题。 递归的缺点？ 递归的本质是函数调用自身。函数的调用有时间和空间的消耗。 函数递归调用的本质的入栈与出栈操作，调用层次太多时，会导致栈溢出。（函数递归时先将父问题和子问题依次压栈，解决最低层子问题之后，再依次弹栈解决父问题。因此任何用递归解决的问题都可以利用栈改成非递归版本）。 递归中可能存在重复子问题计算。（这一点可以通过存储子问题的结果得以解决） 递归的分类？ 数组的递归 链表的递归 树的递归 数组的递归 最长公共子串 链表的递归 树的递归 894. 所有可能的满二叉树 深度优先 广度优先 图 130 200 参考 一文读懂递归算法 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-08 22:57:56 "},"DataStructAndAlgorithm/dynamicProgram.html":{"url":"DataStructAndAlgorithm/dynamicProgram.html","title":"动态规划","keywords":"","body":"回文字符串 LCS Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-10 22:02:57 "},"DataStructAndAlgorithm/bfsDfs.html":{"url":"DataStructAndAlgorithm/bfsDfs.html","title":"DFS & BFS","keywords":"","body":"二叉树的深度优先与广度优先 关于二叉树的深度优先遍历和广度优先遍历： DFS BFS 数据结构 栈 队列 思想 深度优先遍历的思想是从上至下，对每一个分支一直往下一层遍历直到这个分支结束，然后返回上一层，对上一层的右子树这个分支继续深搜，直到一整棵树完全遍历，因此深搜的步骤符合栈后进先出的特点. 广度优先遍历的思想是从左至右，对树的每一层所有结点依次遍历，当一层的结点遍历完全后，对下一层开始遍历，而下一层结点又恰好是上一层的子结点。因此广搜的步骤符合队列先进先出的思想。 优缺点 不全部保留结点，占用空间少；有回溯操作(即有入栈、出栈操作)，运行速度慢。 保留全部结点，占用空间大； 无回溯操作(即无入栈、出栈操作)，运行速度快。 遍历方法 二叉树的深度优先搜索有三种遍历方法：先序遍历：根左右。中序遍历：左根右。后序遍历：左右根。除了利用栈以外，深度优先搜索也可以使用递归的方法。 图的深度优先与广度优先 深度优先遍历(Depth First Search)的主要思想是： 首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点； 当没有未访问过的顶点时，则回到上一个顶点，继续试探别的顶点，直至所有的顶点都被访问过。 广度优先遍历(Depth First Search)的主要思想是：类似于树的层序遍历。 参考： 二叉树的深度优先遍历(DFS)和广度优先遍历(BFS) Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:26:58 "},"DataStructAndAlgorithm/complex.html":{"url":"DataStructAndAlgorithm/complex.html","title":"算法复杂度","keywords":"","body":"圈复杂度 算法复杂度 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:34:26 "},"Golang/Golang.html":{"url":"Golang/Golang.html","title":"其他","keywords":"","body":"Golang Golang github 优点 并发 connection pooling 缺点 适用场景 Golang C/C++ Java Python 数据 slice interface 与 reflect reflect 性能 并发 携程 channel 底层实现 性能与调试 pprof 热点图 Go 语言的高级调试方法 视频 go marshal test 工程 代码依赖 vendor gradlew 代码规范 参考 github CodeReview Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-16 23:17:54 "},"Golang/gocmd.html":{"url":"Golang/gocmd.html","title":"命令行操作","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-16 22:59:59 "},"Golang/gobasic.html":{"url":"Golang/gobasic.html","title":"基础","keywords":"","body":" 1. go import 1.1. packet 与 import 1.2. import操作 2. go main 3. go switch 4. go buildin method 4.1. make 4.2. new 4.3. len cap 4.4. append 4.5. delete 5. go slice 5.1. 格式 6. go map 6.1. 声明与初始化 1. go import 1.1. packet 与 import go通过packet定义包的名称，同一路径下文件的包名必须统一, 建议包名和路径名一致。 go通过import包所在的路径获取包内容，建议填写绝对路径。 import时写路径名，引用时写包名。 1.2. import操作 点操作 例如import .\"fmt\"，那么在使用打印函数时，不需要fmt.Println(\"hello\"), 可以省略写成Println(\"hello\")。 别名操作 例如 import f \"fmt\"，将fmt包设置一个别名f，则在使用打印函数时，可以写成f.Println(\"hello\"). 下划线操作 例如 import _\"github.com/xxx\" 目的是为了调用包中的init函数，而不使用包中的其他方法。 参考文献: https://www.cnblogs.com/qiang-cnblog/p/7819587.html 2. go main main函数所在包必须为main包 一个包内最多只能有一个main方法。（这是显然的，因为在包作用域内，变量或函数名称都应当是唯一的。） main函数不能带参数，没有返回值。 main函数可以通过调用flag包解析命令行参数。 3. go switch 条件表达式可以为空，则默认为true 单个case中，可以出现多个匹配项，例如 case 1,2,3: 每个case结束，不需要用break退出一个case。可以使用falltrough关键字，执行紧跟着的下一个case。 4. go buildin method 4.1. make 用于slice, map, channel, 分配内存并初始化，返回类型的引用（不是指针）。 使用细则 Call | Type T | Result -----|--------|------- make(T,n) | slice | 创建len，cap 均为 n 的 slice make(T,n,m) | slice | 创建 len 为 n, cap 为 m 的slice make(T) | map | 创建map make(T,n) | map | 创建含有n个初值的map make（T）| channel | 无缓存的channel make（T,n） | channel | 缓存大小为 n 的 channel 举例 slice1 := make([]int, 5) map1 := make(map[string]int,5) fmt.Println(slice1). //[0 0 0 0 0] 4.2. new 返回类型的指针。 举例 pslice1 := new([]int) fmt.Println(pslice) //&[0 0] 4.3. len cap 适用于数组，slice, map, channel。 举例 fmt.Println(len(slice1)) 4.4. append 适用于slice。append超过slice的容量时，slice会自动扩容。 用法 slice = append(slice, elem1, elem2, ...) slice = append(slice, anotherSlice) 举例 slice1 = append(slice1,1) slice1 = append(slice1,slice2) 4.5. delete 适用于map，按指定键删除map对应的元素,当元素不存在时，不进行操作。 用法 delete(map,key) 举例delete(map1,\"Mike\") 参考文档： https://blog.csdn.net/uudou/article/details/52241534 5. go slice 5.1. 格式 go语言编译器会自动在以标识符、数字字面量、字母字面量、字符串字面量、特定的关键字（break、continue、fallthrough和return）、增减操作符（++和--）、或者一个右括号、右方括号和右大括号（即)、]、}）结束的非空行的末尾自动加上分号。 因此slice 正确的赋值如下： a1 := []int{ 1,2,3, } a2 := []int{ 1,2,3} 如下赋值方法是错误的 //错误的赋值方法 a3 := []int{ 1,2,3 } 6. go map 6.1. 声明与初始化 声明 var null_map map[string]int 此时，map变量仅被声明了，未被初始化。未初始化的map值为nil，当map未被初始化就被设置元素值时会引起panic。 初始化 map1 := make(map[string]int,5) //初始化容量为5的map map2 := make(map[string]int) map3 := map[string]int{} map4 := map[string]int{1,2,3,4,5} map在初始化时，是否指定初始容量差别不大。当map容量不够时会自动扩容。 6.2. 遍历 for k,v := range map1{ //... } for k := range map2{ //... } go map的遍历是随机、无序的。 6.3. 增删改查 map1 := make(map[string]int) map1[\"a\"] = 1 //增加元素 map1[\"a\"] = 0 //修改元素 delete(map1,\"a\") //删除元素 if val, ok := map1[key]; ok{ //查找元素 //...key元素存在... } map的删除使用内置函数delete，该函数没有返回值。当删除的元素不存在时，delete不会做任何操作。 查找操作时，返回两个值，分别是索引key对应的val，与本次索引是否成功。 比较两个map是否相等，需要遍历比较它们的键值对是否完全相等。 > 参考文献 https://blog.csdn.net/xiangxianghehe/article/details/78790744 go interface interface{}是可以指向任意对象的Any类型。 一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口 实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理 类实现接口时，需要导入接口所在的包 接口由使用方按自身需求来定义，使用方无需关心是否有其他模块定义过类似的接口 方法 go中没有类，可以通过为结构体类型定义方法实现类的功能。 只能为在同一包内定义的类型声明方法，不能为在其他包内定义的类型以及内建类型（如int）等声明方法。 方法接收者类型为指针接收者的优点（对比值类型接收者）： 方法能够修改接收者指向的值； 避免每次在调用方法时复制该值，若值的类型为大型结构体时，将接收者类型设置为指针类型会更高效。 接口 ... go defer 功能 将函数推迟到外层函数返回后执行。\b 注意：推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。 例： func testf(a *int){ defer fmt.Println(\"testf1:\",*a) *a=100 fmt.Println(\"testf2:\",*a) } func main(){ a:=10 defer fmt.Println(\"1:\",a) testf(&a) fmt.Println(\"2:\",a) } 输出结果： testf2:100 testf1:10 2:100 1:10 使用陷阱 go panic 错误是业务过程的一部分，而异常不是。 go vet 功能 go vet 是go tool套件的一部分，用于代码静态检查,在代码编译与运行阶段发现bug，废弃代码等。 使用方法 go tool vet 或 go vet go vet 与go tool vet go vet，只在一个单独的包内可用，不能使用flag 选项（来激活某些指定的检测）。 go tool vet更加完整，它可用用于文件和目录。目录被递归遍历来找到包。go tool vet也可以按照检测的分组激活选项。 （可以打开一个终端，比较go vet --help 和go tool vet --help两个命令的不同。） 参考文献 https://studygolang.com/articles/9619 go convey 功能 goconvey是一个支持golang的单元测试框架 goconvey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面 goconvey提供了丰富的断言简化测试用例的编写 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-16 14:57:00 "},"Golang/godebug.html":{"url":"Golang/godebug.html","title":"Debug","keywords":"","body":"GO Debug Go 调试的方式有很多种，包括通用的Rubber duck debugging, 打印，古早的GDB（适合CGO项目的调试），以及go专属的调试工具delve。此外，golang 提供了一种可以进行Google Analytics(GA)用户活动追踪的第三方库ogle. 打印 这里主要介绍第三方库go-spew。 go-spew go的第三方库go-spew对go的原始打印方法进行了封装，可以打印出数据的详细数据结构、地址(如果是指针类型)、值内容，用于go的debug。🔗GoDock1,🔗GoDock2. go-spew 提供了诸如spew.Dump 以及spew.Println等方法。 快速开始： import \"github.com/davecgh/go-spew/spew\" type stru struct{ i int } func main(){ var a=100 var b=stru{200} var c=&stru{200} spew.Dump(a) spew.Dump(b) spew.Dump(c) } 输出结果： (int) 100 (main.stru) { i: (int) 200 } (*main.stru)(0xc0000161b0)({ i: (int) 200 }) delve dwarf 二进制调试数据 dwarf dwarf gp build -ldflags=-w dlv debug dlv test (dlv)b package.func 设置断点 (dlv)c 显示函数 (dlv)n 下一步 (dlv)set val (dlv)cal func (dlv)config -list (dlv)help Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-16 23:04:28 "},"Database/database.html":{"url":"Database/database.html","title":"数据库","keywords":"","body":"Database 数据库索引 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-05 00:49:18 "},"DistributionSystem/distributionSystem.html":{"url":"DistributionSystem/distributionSystem.html","title":"分布式系统","keywords":"","body":"微服务 https://mp.weixin.qq.com/s/OAjcQdQxQzTRRv6q52JPNg https://mp.weixin.qq.com/s/mJ_jZZoak7uhItNgnfmZvQ zookeeper redis 强一致性 秒杀系统 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-15 08:06:58 "},"DesignPattern/designPattern.html":{"url":"DesignPattern/designPattern.html","title":"设计模式","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-12 23:21:05 "},"Logic/logic.html":{"url":"Logic/logic.html","title":"智力题","keywords":"","body":"查找 赛马次数 有 25 匹马和 5 条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前 3 名。 先把 25 匹马分成 5 组，进行 5 场赛马，得到每组的排名。再将每组的第 1 名选出，进行 1 场赛马，按照这场的排名将 5 组先后标为 A、B、C、D、E。可以知道，A 组的第 1 名就是所有 25 匹马的第 1 名。而第 2、3 名只可能在 A 组的 2、3 名，B 组的第 1、2 名，和 C 组的第 1 名，总共 5 匹马，让这 5 匹马再进行 1 场赛马，前两名就是第 2、3 名。所以总共是 5+1+1=7 场赛马。 A 组：1，2，3，4，5 B 组：1，2，3，4，5 C 组：1，2，3，4，5 D 组：1，2，3，4，5 E 组：1，2，3，4，5 九球称重 有 9 个球，其中 8 个球质量相同，有 1 个球比较重。要求用 2 次天平，找出比较重的那个球。 将这些球均分成 3 个一组共 3 组，选出 2 组称重，如果 1 组比较重，那么重球在比较重的那 1 组；如果 1 组重量相等，那么重球在另外 1 组。 对比较重的那 1 组的 3 个球再分成 3 组，重复上面的步骤。 药丸称重 有 20 瓶药丸，其中 19 瓶药丸质量相同为 1 克，剩下一瓶药丸质量为 1.1 克。瓶子中有无数个药丸。要求用一次天平找出药丸质量 1.1 克的药瓶。 可以从药丸的数量上来制造差异：从第 i 瓶药丸中取出 i 个药丸，然后一起称重。可以知道，如果第 i 瓶药丸重 1.1 克/粒，那么称重结果就会比正常情况下重 0.1 * i 克。 扔鸡蛋 todo!!! 一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少。 可以将楼层划分成多个区间，第一个鸡蛋 E1 用来确定 N 属于哪个区间，第二个鸡蛋 E2 按顺序遍历该区间找到 N。那么问题就转换为怎么划分区间满足最坏情况下扔鸡蛋次数最少。 E1 需要从第一个区间开始遍历到最后一个区间。如果按等大小的方式划分区间，即 E2 的遍历次数固定。那么最坏的情况是 N 在最后一个区间，此时 E1 遍历的次数最多。为了使最坏情况下 E1 和 E2 总共遍历的次数比较少，那么后面的区间大小要比前面的区间更小。具体来说，E1 每多遍历一次，E2 要少遍历一次，才使得 N 无论在哪个区间，总共遍历的次数一样。设第一个区间大小为 X，那么第二个区间的大小为 X-1，以此类推。那么 X + (X-1) + (X-2) + … + 1 = 100，得到 X (X + 1) / 2 = 100 ，即 X = 14。 老鼠喝酒 一共1000瓶酒，其中一瓶有毒。如果一只老鼠喝了有毒的酒，会在一天之后死亡，那么如果给你一天时间，然你判定哪瓶酒有毒，至少需要几只老鼠？ 答案 答案是10只。这个需要使用二进制编码来解决，1000瓶酒至少需要10位二进制数来进行编码。然后取十只杯子分别代表这是个二进制数的十个位，分别将1000瓶酒倒入其编码为1的对应的杯子中。取十个老鼠分别喝十个杯子中的酒，一天之后，就可以根据喝哪些杯子的老鼠死掉来确定出有毒的那瓶酒的编码，从而确定哪瓶酒有毒。其根据就是只有有毒酒的编码对应的毒死老鼠的杯子位置。这个题目就是利用了二进制编码的一些特性。 国王有10000桶酒，已知一桶酒有毒，喝了之后一定会在23-24小时内死亡（例如0点喝，会在23-第二天0点这个时间段死亡）。现在国王要在48小时后举办一个宴会，需要用罪犯实验，请问最少几个罪犯。（可以混合酒） 如果是常规利用二进制解题的话，那就需要14个犯人，2^14=16384>10000，但是这样一来死亡时间这个条件就用不到，也不是最优解。 应该利用酒死的时间是固定的，一个罪犯像上面那样可以表示成25种状态，三个罪犯就可以表示25 x 25 x25种状态，超过10000了，所以只需要三个罪犯。 拓展 还有一些其他的题目也使用这些特性，比如使用特殊的位运算，一般使用比较多的位运算就是与、或和异或。 这样，就可以对应到现实生活中的一些为题，比如一个类似的问题原本我们想需要用900多台服务器来解决，经过这样分析后就可以使用10台服务器来解决，大大节约了成本。 计量 用绳子计时 15 分钟 给定两条绳子，每条绳子烧完正好一个小时，并且绳子是不均匀的。问要怎么准确测量 15 分钟。 点燃第一条绳子 R1 两头的同时，点燃第二条绳子 R2 的一头； 当 R1 烧完，正好过去 30 分钟，而 R2 还可以再烧 30 分钟； 点燃 R2 的另一头，15 分钟后，R2 将全部烧完。 得到指定容量的水 有两个杯子，容量分别为 5 升和 3 升，水的供应不断。问怎么用这两个杯子得到 4 升的水。 可以理解为用若干个 5 和 3 做减法得到 4。 不能从 3 做减法得到 4，那么只能从 5 做减法得到 4，即最后一个运算应该为 5 - 1 = 4，此时问题转换为得到 1 升的水； 1 升的水可以由 3 做减法得到，3 - 2 = 1，此时问题转换为得到 2 升的水； 5 - 3 = 2。 一个5L，一个6L的瓶子，要得到3L的水，问什么方法 答案 6-5=1 1L水放在5L那个瓶里面，然后再装6L水，往5L（里面已经有1L）里面倒，这样就会剩下2L水在6L里面，再把2L水放在5L里面，再装一次，不就可以6L那里到处3L水到5L里面，自己就剩下3L了 红白帽子推理 一群人开舞会，每人头上都戴着一顶帽子。帽子只有黑白两种，黑的至少有一顶。每个人都能看到其它人帽子的颜色，却看不到自己的。主持人先让大家看看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的是黑帽子，就打自己一个耳光。第一次关灯，没有声音。于是再开灯，大家再看一遍，关灯时仍然鸦雀无声。一直到第三次关灯，才有劈劈啪啪打耳光的声音响起。问有多少人戴着黑帽子？ 答案 三个人 若是两个人，设A、B是黑帽子,第二次关灯就会有人打耳光。原因是A看到B第一次没打耳光，就知道B也一定看到了有带黑帽子的人，可A除了知道B带黑帽子外，其他人都是白帽子，就可推出他自己是带黑帽子的人！同理B也是这么想的，这样第二次熄灯会有两个耳光的声音。 如果是三个人，A,B,C。A第一次没打耳光，因为他看到B,C都是带黑帽子的；而且假设自己带的是白帽子，这样只有BC戴的是黑帽子；按照只有两个人带黑帽子的推论，第二次应该有人打耳光；可第二次却没有...于是他知道B和C一定看到了除BC之外的其他人带了黑帽子，于是他知道BC看到的那个人一定是他，所以第三次有三个人打了自己一个耳光 拓展: N个人是黑帽子，就会在第N天，有N个人打自己一个耳光。 吃药片 一个是两种药片，每种有两个，一个人需要早上吃两种药片各一个，现在这四个药片混在一起了这个人什么方法吃。 答案 把所有的4颗药丸都切开成相等的两半，然后早上和晚上，分别吃掉每颗药丸的一半 操作 飞机加油 本体图解参考：https://blog.csdn.net/hinyunsin/article/details/6632062 已知： 每个飞机只有一个油箱，飞机之间可以相互加油（注意是相互，没有单独的加油机），一箱油可供一架飞机绕地球飞半圈。问题：为使至少一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机？（所有飞机从同一机场起飞，而且必须安全返回机场，不允许中途降落，中间没有飞机场） 答案 分为3架飞机5架次和3架飞机6架次 3架飞机6架次 ABC 3架同时起飞 1/8处，C给AB加满油，C返航。此时飞机的油量分别是：A: 3/4, B: 3/4, C: 3/4。此时C分别给A和B加满油，三架飞机当前油量分别是：A: 1, B: 1, C: 1/4。C返回机场。A、B继续向前飞行。 1/4处，B给A加满油，B返航，A到达1/2处，此时C已经返回机场，三家飞机此时油量分别是：A: 3/4, B: 3/4, C: 0。此时B给A加满油，C加满油，此时三架飞机的油量分别是：A: 1, B: 1/2, C: 1。然后B返回机场，A继续向前飞行。 当A飞行至半圈位置时，B已经返回机场并且加满了油（假设加油时间为0），此时，B和C沿逆时针方向飞行，三架飞机当前油量分别是：A: 1/2, B: 1, C: 1。A继续向前飞行。 当A飞行至另外半圈的1/4位置时，三架飞机剩余油量分别是：A: 1/4, B: 3/4, C: 3/4。此时，C给B加满油。此时三架飞机油量分别是：A: 1/4, B: 1, C: 1/2。C返回机场，B和A继续向前飞行。 当A飞行至另外半圈的1/2位置时，C已经返回机场，A和B相遇，此时三架飞机剩余油量分别是：A: 0, B: 3/4, C: 0。B给A加1/4的油，三架飞机剩余油量：A: 1/4, B: 1/2, C: 1。C加满油从机场逆时针飞出，B返回机场，A继续向前飞行。 当A飞行至另外半圈的3/4位置时，A和C相遇。此时三架飞机的油量分别是：A: 0, B: 1/4, C: 3/4。C给A加1/4的油，此时三架飞机的油量分别是：A: 1/4, B: 1/4, C: 1/2。C掉头返回机场，A和B继续向前飞行。 三架飞机顺利回到机场！ 3飞机5架次 （1）3 架飞机同时从机场出发，飞行八分之一周（A点），各耗油四分之一。此时某架飞机给其余两架补满油，自己返回基地； （2）另一架飞机和目标机结伴，飞至四分之一周（B点），给目标机补满油，自己返回； （3）目标机独自飞行半周（C点）； （4）与从基地反向出发的一架飞机相遇，2 机将油平分，飞至最后八分之一处（D点）； （5）与从基地反向出发的另一机相遇，各分四分之一油，返回。 移动玻璃杯 周雯的妈妈是豫林水泥厂的化验员。 一天，周雯来到化验室做作业。做完后想出去玩。 \"等等，妈妈还要考你一个题目，\"她接着说，\"你看这6只做化验用的玻璃杯，前面3只盛满了水，后面3只是空的。你能只移动1只玻璃杯，就便盛满水的杯子和空杯子间隔起来 吗?\" 爱动脑筋的周雯，是学校里有名的\"小机灵\"，她只想了一会儿就做到了。请你想想看，\"小机灵\"是怎样做的? 把第二个满着的杯子里的水倒到第五个空着的杯子里 枪战 todo!!! 三个小伙子同时爱上了一个姑娘，为了决定他们谁能娶这个姑娘，他们决定用手枪进行一次决斗。小李的命中率是30％，小黄比他好些，命中率是50％，最出色的枪手是小林，他从不失误，命中率是100％。由于这个显而易见的事实，为公平起见，他们决定按这样的顺序：小李先开枪，小黄第二，小林最后。然后这样循环，直到他们只剩下一个人。那么这三个人中谁活下来的机会最大呢？他们都应该采取什么样的策略？ 小黄。 因为小李是第一个出手的，他要解决的第一个人就会是小林，这样就会保证自己的安全，因为如果小黄被解决，自己理所当然地会成为小林的目标，他也必定会被打死。而小黄如果第一枪不打小林而去打小李，自己肯定会死（他命中较高，会成为接下来的神枪手小林的目标）。他必定去尝试先打死小林。那么30% 50%的几率是80%（第一回合小林的死亡率，但会有一点点偏差，毕竟相加了）。那么第一回合小黄的死亡率是20%多一点点（小林的命中减去自己的死亡率）。假设小林第一回合死了，就轮到小李打小黄了，那么小李的命中就变成了50%多一点点(自己的命中加上小黄的死亡率）。这样就变成了小李小黄对决， 第二回合的小李的第一枪命中是50%，小黄也是。可是如果拖下去的话占上风的自然就是小黄了，可能赢得也自然是小黄了。至于策略我看大家都领悟了吧。 硬币覆盖 todo!!! 在一张长方形的桌面上放了n个一样大小的圆形硬币。这些硬币中可能有一些不完全在桌面内，也可能有一些彼此重叠；当再多放一个硬币而它的圆心在桌面内时，新放的硬币便必定与原先某些硬币重叠。请证明整个桌面可以用4n个硬币完全覆盖 假如先前N个中没有重叠且边上的都超出桌子的边上且全都是紧靠着的.那么根据题意就可以有: 空隙个数Y=3N/2+3(自己推算), 每一个空都要一个圆来盖, 桌面就一共有圆的数为: Y = N+3N/2+3 = 5N/2+3 所以可以用4N个硬币完全覆盖. 参考： 面试智力题集锦 75道程序员面试逻辑题和答案 精选程序员面试常问的逻辑题 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-21 13:02:03 "},"Project/project.html":{"url":"Project/project.html","title":"项目","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-15 07:50:44 "},"Project/flowCtrol.html":{"url":"Project/flowCtrol.html","title":"流量控制","keywords":"","body":"简介 流量控制是在通信系统中系统过载或网络拥塞时，主动减少接纳或发出的业务量，防止系统崩溃并将实际接纳业务量逼近网络处理能力的一种故障自动恢复机制。 流控的方法包括拥塞控制和过载控制两种。拥塞控制主要是配置系统每秒最大的数据报文的处理数量，当超过这个界限的时候就丢弃数据。一般是对于通信业务流程的首消息进行的，数据报的的数量对应着用户数。这个值是通过经验值来设定的，代表设备最大的接入量。 过载控制主要是根据CPU的使用量，CPU用量超过80%且持续5秒，就判断系统过载，然后根据控制理论的PID原理为不同优先级的消息分配令牌，没有获得令牌的消息就会被流控掉。 遇到的挑战 这个任务的时间比较紧，除了流控功能之外，还有许多辅助的配置命令，流控告警功能需要开发。解决方法：将问题分解，逐个开发，分批次合入代码，保证功能持续可用与功能增强。 流控功能的验证，因为一般的测试环境构造不了大话务的场景，所以需要想办法，在网上搜索人为提高CPU使用率的方法。达到流控门限，然后测试流控的功能。 验证的时候发现了已经流控掉，但是CPU和内存都冲高导致微服务挂掉，一开始不知道是哪有问题，后开看了error日志，发现一致循环打某个调用栈，内存耗尽导致。那个地方是封装的一个error接口，error里面又有error，导致存在无穷递归调用。 亮点 在着手之前，对流控功能需求和实现原理了解了一下，并且设计了全套的业务流控，包括流控的功能实现、参数配置功能、告警功能、消息数目数据统计功能等一系列的看护手段。保证了功能的健壮性。 【复盘改进】 由于时间太赶，在前期设计细节研究不够，导致部分理解偏差，实现不人性化。比如上报系统过载的告警，应该是在系统从非流控状态切换到流控状态的时候，发出一条消息，告诉周边模块本模块过载了。但是，我原始实现的是每当有一条消息被流控掉，就上报告警，这样会导致系统严重过载时界面上出现很多告警。其实就和设计衣服或者房子一样，在动手前，最好做出一个高保真的模型，避免返工。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-01-16 23:41:51 "},"Self/self.html":{"url":"Self/self.html","title":"Self","keywords":"","body":"Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-05 21:41:23 "},"Self/daily.html":{"url":"Self/daily.html","title":"Daily","keywords":"","body":"2020 February 2020.02.05 Wednesday Plan 《人生十二法则》 Summary 缘于昨日刷微博至凌晨，完事之后顿觉空虚，愧对自己。冲了个澡后又清醒了一些，想了想自己现在究竟在干什么，暗地下定决定戒掉微博，撑满21天。今日轻松完成任务，值得自我表扬。 2020.02.06 Thursday Plan 树的遍历：二叉树层序遍历 -OK，从前序中序重建二叉树-OK。 Summary 公司的工作上完成了一个冗余代码的整改，使用了go的reflect库函数，顺便还用Benchmark测试了一下运行时间，影响不大。自己的工作今天只写了2道题，按道理晚上时间挺多的。不过没有过多的娱乐，很不错。加油哦！ 2020.02.07 Friday Plan nil Summary 今日就一直在整go的interface，被一个问题困住了，一直在尝试怎么样将一个值是指针的interface{} 转成指是非指针的interface{}.所以原本列的自己的工作就没做，计划推到明天。 2020.02.08 Saturday Plan 树的遍历：从中序后序重建二叉树-ok, 从前序后序重建二叉树-ok Summary 在惴惴不安下周一就要去公司，为此买了一个新的oppo手机以便旧手机用来打卡，还是有一些期待的；还在忏悔对长辈说了无理的话，虽然没有恶意，但是语气不对，很难为情。左思右想，胡思乱想，想想，还是多看看书吧。决定继续看《人生十二法则》了。现在看完了第一章节，总结来说，我们需要保持良好的体态，形成一个正反馈，昂首挺胸，美好的事物会接踵而至。看完书准备去睡觉咯。P.s. 已经坚持4天没看微博了。棒棒哒！ 2020.02.09 Sunday Plan go slice，go test，go 热力图,go map 源码 源码解读， interface{}, reflect Summary 今天不记得干了啥了，似乎是一道leetcode，还没做出来明天要出门上班了，郁闷。 2020.02.10 Monday Plan 编解码N2冗余代码整改-ok Summary 记疫情后的第一天复工 早上起床起的挺早的，不打算和人挤在一起，所以就8点30才出门，等到楼下过了马路之后，一看手表，已经8点50了，于是和尖哥一路疾走，终于在8点58分打上了卡。两人穿的都是厚棉袄加厚绒裤，尖哥额头上都冒出细密的汗珠子了。 到了基地，南小门那里放了一些警示牌，掏出工卡，就进去了，没有测温，没有检查入园短信。走道星巴克那里，站着两个工作人员，其中一个人手上拿了测温枪。检查了入园短信之后放我进去了，还有一个人和我同时到达，为了不聚集，我特意避让了一下。又往前走了几步之后发现没有测温，于是我又回过头来说，还没有测温。手上拿着测温枪的那个人示意我到里面去测温。我往里看了一下过来还有一道关卡，测温的是脖子，36度。我侧头一看，发现平时休息的沙发已经变成测温等候区，测温不通过的会在这等一会再测。 到了食堂，路的一侧摆着很多张小桌子，桌子上放着一个白色的微波炉，旁边还有一瓶免洗洗手液。我径直往里走，上楼，去了洗手间，台子也摆着两瓶洗手液，我惊讶哪收集来的这么多洗手液，我想买而买不到。用纸垫着挤了点给手消了消毒。抬头看镜子，我的脸蛋儿被口罩挤的都咧吧了，左边眼睛都被挤小了，活像一个被五花大绑的肉粽。 到了办公室，人密密麻麻。每个人坐在自己的格子间，带着口罩。我来到我的座位，用纸擦了擦座椅和桌子，从抽屉里拿出放假前放进去的鼠标，开始工作了。在家用笔记本，屏幕比较小，远程连接的速度也是堪忧，所以在公司办公对比起来办公环境还是好一些的。但是口罩几乎让我窒息，感觉大脑缺氧，又懒得洗杯子摘口罩喝水，感觉整个人晕乎乎的，嗓子眼也很难受。 11点半走消防通道下去放风，摘掉了口罩上面一根带子，终于能松绑了。迎着太阳，太阳是耀眼的，也是有温度的，希望太阳能照耀这大地，消灭灾难。走在这条阳光铺满的路上，树叶的影子在地上斑驳。路的一边，山茶花热闹非凡，大红色的花，似铃铛一般，召唤来蜜蜂。蜜蜂们飞上舞下，忙得不亦乐乎。它们是简单的，也是快乐的，人间的这一切与它们无干。 准备回去吃饭了。从保温袋中拿出饭盒，又抽了一张纸垫着打开了茶水间的微波炉。纸张太小，饭盒偏大，十分别扭的终于将饭盒放进了微波炉，加热好后又十分别扭的拿出饭盒，放回保温袋拿到座位上。解下了口罩，开始吃了起来。其实解下口罩的那一时刻，心里在想，好像也没什么。就像卸下防弹衣的战士没有感觉到显而易见的威胁，也许这是许多人敢不戴口罩的原因吧。吃完最后一口，嘴里的还没嚼着咽下，就抹了抹嘴先把口罩戴上了，然后继续咀嚼最后一口。 约莫中午1点的时候，办公室关了灯，准备开始午睡了。一上午的缺氧让脑子本身就已经晕乎乎的了，不一会就入睡了。朦朦胧胧中睡的很浅，也不踏实。 下午的时间也在缺氧中度过，也在一直期待着发口罩，一直快到下班的前一刻才拿到口罩。下班了准备回家，尖哥有点小感冒，他领导让他先在家办公一段时间。我们带着口罩就这样一路走一路说，回了家。路上没有什么人，风也挺大的，我提议说要不要摘下口罩呼吸一下新鲜空气，尖哥担心气溶胶传播，所以只好作罢。 回到家，把外套脱了挂在架子上，用湿纸巾擦了一下钥匙和工卡。准备洗澡做饭了，就此结束了一天的室外战斗，噫吁嚱！ 2020.02.11 Tuesday Plan 全排列，一个数可以由几个数相加 Go interface Summary 今天开始继续在家远程办公，可能因为远程办公的人少了一波，电脑连接速度流畅了很多，鼠标也没有时延了。 2020.02.12 Wednesday Summary 沉下心来，看了一晚上的《愿人生从容》。 快与慢 未完待续...... 2020.02.13 Thursday Plan 树的遍历：从先序遍历还原二叉树-ok Summary 报名了周日的leetcode周赛；写了几天前悬而未决的leetcode题；更新了gitbook到github上。9天没看微博了。明天得去公司办公，不能在家远程了。 2020.02.14 Friday Plan linux目录拷贝 Summary 今天又去了公司，到中午的时候后脑勺很疼，不知道是缺氧还是口罩橡皮筋勒的，很不舒服。晚上吃完饭八点多了，拖了个地，洗了个澡澡就睡美容觉了。 2020.02.15 Saturday Plan 10:10-10:40 树的遍历完结：翻转二叉树以匹配先序遍历-ok 10:40-11:30 11:30-12:00 扒舞 14:00-15:00 bilibili go 调试视频 -ok 15:00-16:30 leetcode 往期175周赛题模拟 16:40-17:30 计算机网络TCP/IP bilibili go 信号量/connection pooling 面试视频 Summary 今天的流水账：早上起床还挺早的，然后用手机看了一会电子书，就看困了，坐在椅子上打了会盹。之后又制定计划，我发现如果只列需要做的事情，不订好时间，我很容易就不去遵守，所以我还是把具体时间计划写上。 上午写了一题leetcode。下午起床比较晚，看了哔哩哔哩关于go调试的视频已经到3点多。时间一旦计划打乱，就容易miss。 2020.02.16 Sunday Plan 9:00-10:00 树的遍历整体梳理 10:10-10:30 leetcode 模拟题 10:30-12:00 leetcode 176周赛-ok(排名276/2409) 14:00-16:00 go dlv 16:00-17:00 go 热力图 17:00-17:30 跳操 todo: 二维数组 按第一个数排序 bilibili go系列视频 bilibili go信号量 go 编译链接文章, 视频 Summary 看了一个关于go debug的视频，知道了许多东西。感觉看这些讲解视频比单纯看文字类的东西更能开阔视野，毕竟录制视频公开课的门槛高于写文档。以后多看看这方面的。 2020.02.17 Monday Plan 8:00-8:20 阅读《人生十二法则》 12:00-12:50 golang dwarf 20:00-20:30 leetcode 5343 22:00-23:00 总结leetcode 176周赛 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-17 08:02:05 "},"Self/read.html":{"url":"Self/read.html","title":"Reading","keywords":"","body":"摘抄 愤怒和敌对的确可能引发暴躁和混乱，但同时也可以驱动我们反抗压迫，坚持真理，在未知险途上坚定前行。 ——乔丹*彼得森《人生十二法则》 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-08 23:12:51 "},"Self/poetry.html":{"url":"Self/poetry.html","title":"诗词","keywords":"","body":"志向篇 登科后 孟郊 昔日龌龊不足夸，今朝放荡思无涯。 春风得意马蹄疾，一日看尽长安花。 龌龊：此处指不如意。 放荡：自由自在，无拘无束。 思无涯：兴致高涨。 疾：快。 行路难（其一） 李白 金樽清酒斗十千，玉盘珍羞直万钱。 停杯投箸不能食，拔剑四顾心茫然。 欲渡黄河冰塞川，将登太行雪满山。 闲来垂钓碧溪上，忽复乘舟梦日边。 行路难！行路难！多歧路，今安在？ 长风破浪会有时，直挂云帆济沧海。 闲来垂钓二句：暗用典故姜太公钓鱼和伊尹梦见自己乘船从日月旁经过，姜公助周文王灭商，伊尹助商汤灭夏。表示对从政尚有期待。 长风破浪：南朝宋名将宗悫què少年时志向“愿乘长风破万里浪”。 柔情篇 钗头凤·红酥手 陆游 红酥手，黄縢酒，满城春色宫墙柳。东风恶，欢情薄。一怀愁绪，几年离索。错错错。 春如旧，人空瘦。泪痕红浥鲛绡瘦。桃花落，闲池阁。山盟虽在，锦书难托。莫莫莫。 红润酥腻的手里，捧着盛上黄縢酒的杯子。满城荡漾着春天的景色，你却早已像宫墙中的绿柳那般遥不可及。春风多么可恶，欢情被吹得那样稀薄。满杯酒像是一杯忧愁的情绪，离别几年来的生活十分萧索。错，错，错！（错误，错落，错责） 美丽的春景依然如旧，只是人却白白相思地消瘦。泪水洗尽脸上的胭脂红，又把薄绸的手帕全都湿透。满春的桃花凋落在寂静空旷的池塘楼阁上。永远相爱的誓言还在，可是锦文书信再也难以交付。莫，莫，莫！（罢了） 钗头凤·世情薄 唐婉 世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残，欲笺心事，独语斜阑。难难难。 人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊，怕人询问，咽泪装欢。瞒瞒瞒。 阑珊：将尽。 青玉案·凌波不过横塘路 贺铸 凌波不过横塘路，但目送，芳尘去。锦瑟华年谁与度？月桥花院，琐窗朱户，只有春知处。 碧云冉冉蘅皋暮，彩笔新题断肠句。试问闲愁都几许？一川烟草，满城风絮，梅子黄时雨。 Copyright © ZengMenglu 2020 all right reserved，powered by Gitbook本书发布时间： 2020-02-12 23:28:13 "}}